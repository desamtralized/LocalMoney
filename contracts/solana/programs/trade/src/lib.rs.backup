#![deny(arithmetic_overflow)]
#![deny(unused_must_use)]
#![deny(clippy::arithmetic_side_effects)]
#![forbid(unsafe_code)]
use anchor_lang::prelude::*;
use anchor_lang::AccountDeserialize;
use anchor_lang::solana_program;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token_interface::{
    transfer_checked, Mint, TokenAccount, TokenInterface, TransferChecked,
};
use hub::{require_not_paused, Operation};
use localmoney_shared::{
    calculate_rent_with_margin, validate_token_interface_program,
    ArbitratorPool, BoundedStateHistory, BoundedString, FiatCurrency, RentError,
    RentValidation, SafeMath, TradeState, TradeStateItem, ValidatedCpiContext,
    TradeCreatedEvent, EscrowFundedEvent, FeeDistributionEvent, TradeCompletedEvent,
    TradeStateChangeEvent, DisputeResolvedEvent, SecurityAlertEvent,
};
use std::collections::HashMap;

declare_id!("5osZqhJj2SYGDHtUre2wpWiCFoBZQFmQ4x5b4Ln2TQQM");

mod validation;
pub mod vrf;
use vrf::*;

// Security flags - all validations enabled
const SKIP_HEAVY_VALIDATIONS: bool = false;
const SKIP_PROFILE_CPI_UPDATES: bool = false;
const CREATE_TRADE_EARLY_RETURN: bool = false;
const CREATE_TRADE_RETURN_IMMEDIATELY: bool = false;

#[program]
pub mod trade {
    use super::*;
    use crate::validation::*;

    pub fn create_trade(ctx: Context<CreateTrade>, params: CreateTradeParams) -> Result<()> {
        // CIRCUIT BREAKER: Check if trading is paused
        require_not_paused!(&ctx.accounts.hub_config, Operation::CreateTrade);

        // Validate rent exemption before creation
        ctx.accounts.validate_rent_exemption()?;

        // All validations are now enabled

        let trade = &mut ctx.accounts.trade;
        let clock = Clock::get()?;

        // Deserialize offer from unchecked account for required fields
        // Deserialize offer into owned struct to avoid lifetime issues
        let mut offer_data_slice: &[u8] = &ctx.accounts.offer.data.borrow();
        let offer_acc: offer::Offer = offer::Offer::try_deserialize(&mut offer_data_slice)?;

        // COMPREHENSIVE VALIDATION: Validate trade amount with USD conversion
        validate_trade_amount_with_usd_conversion(
            params.amount,
            ctx.accounts.token_mint.decimals,
            params.locked_price,
            &offer_acc.fiat_currency,
            &ctx.accounts.hub_config,
            &ctx.accounts.price_program.to_account_info(),
        )?;

        // SECURITY: Validate account security
        // Create temporary trade struct using Box to reduce stack usage
        let temp_trade = Box::new(Trade {
            id: params.trade_id,
            offer_id: params.offer_id,
            buyer: ctx.accounts.buyer.key(),
            seller: offer_acc.owner,
            arbitrator: params.arbitrator,
            token_mint: ctx.accounts.token_mint.key(),
            amount: params.amount,
            fiat_currency: offer_acc.fiat_currency.clone(),
            locked_price: params.locked_price,
            state: TradeState::RequestCreated,
            created_at: clock.unix_timestamp as u64,
            expires_at: (clock.unix_timestamp as u64).safe_add(params.expiry_duration)?,
            dispute_window_at: None,
            state_history: BoundedStateHistory::new(),
            buyer_contact: BoundedString::from_option(Some(params.buyer_contact.clone()))?,
            seller_contact: None,
            bump: ctx.bumps.trade,
        });
        validate_account_security(
            &ctx.accounts.buyer.key(),
            &temp_trade,
        )?;

        // AUTHORIZATION: Ensure buyer is not the offer owner
        require!(ctx.accounts.buyer.key() != offer_acc.owner, ErrorCode::SelfTradeNotAllowed);

        trade.id = params.trade_id;
        trade.offer_id = params.offer_id;
        trade.buyer = ctx.accounts.buyer.key();
        trade.seller = offer_acc.owner;
        trade.arbitrator = params.arbitrator;
        trade.token_mint = ctx.accounts.token_mint.key();
        trade.amount = params.amount;
        trade.fiat_currency = offer_acc.fiat_currency.clone();
        trade.locked_price = params.locked_price;
        trade.state = TradeState::RequestCreated;
        trade.created_at = clock.unix_timestamp as u64;
        trade.expires_at = (clock.unix_timestamp as u64).safe_add(params.expiry_duration)?;
        trade.dispute_window_at = None;
        // Initialize history and record first state
        trade.state_history = BoundedStateHistory::new();
        trade.state_history.push(TradeStateItem {
            actor: ctx.accounts.buyer.key(),
            state: TradeState::RequestCreated,
            timestamp: clock.unix_timestamp,
        })?;
        // Buyer contact with full validation
        trade.buyer_contact = BoundedString::from_option(Some(params.buyer_contact))?;
        trade.seller_contact = None;
        trade.bump = ctx.bumps.trade;

        // Continue with full execution

        // Update profile statistics via CPI
            // SECURITY: Validate CPI call to profile program
            validate_cpi_call_security(
                &ctx.accounts.profile_program.key(),
                &ctx.accounts.hub_config.profile_program,
                &[0u8], // Basic non-empty check
            )?;

            // Update buyer profile stats via CPI (buyer authorizes)
            let cpi_program = ctx.accounts.profile_program.to_account_info();
            let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
                profile: ctx.accounts.buyer_profile.to_account_info(),
                actor: ctx.accounts.buyer.to_account_info(),
                buyer: ctx.accounts.buyer.to_account_info(),
                seller: ctx.accounts.seller.to_account_info(),
                arbitrator: ctx.accounts.buyer.to_account_info(), // not used in this transition
            };
            let cpi_ctx = ValidatedCpiContext::new(
                cpi_program,
                cpi_accounts,
                &ctx.accounts.hub_config.profile_program,
            )?;
            profile::cpi::update_trade_stats(cpi_ctx.into_inner(), TradeState::RequestCreated)?;

        // Emit trade creation event
        emit!(TradeCreatedEvent {
            trade_id: params.trade_id,
            offer_id: params.offer_id,
            buyer: ctx.accounts.buyer.key(),
            seller: offer_acc.owner,
            amount: params.amount,
            token_mint: ctx.accounts.token_mint.key(),
            fiat_currency: format!("{:?}", offer_acc.fiat_currency),
            locked_price: params.locked_price,
            timestamp: clock.unix_timestamp,
            buyer_index: ctx.accounts.buyer.key(),
            seller_index: offer_acc.owner,
        });

        Ok(())
    }

    pub fn accept_request(ctx: Context<AcceptRequest>, seller_contact: String) -> Result<()> {
        let trade = &mut ctx.accounts.trade;
        let clock = Clock::get()?;

        // COMPREHENSIVE AUTHORIZATION: Validate seller authorization
        validate_comprehensive_authorization(
            &ctx.accounts.seller.key(),
            trade,
            AuthorizationRole::Seller,
        )?;

        // ADVANCED STATE VALIDATION: Validate state transition
        validate_state_transition(
            &trade.state,
            &TradeState::RequestAccepted,
            &ctx.accounts.seller.key(),
            trade,
            clock.unix_timestamp as u64,
        )?;

        // SECURITY: Additional input validation
        require!(
            !seller_contact.trim().is_empty(),
            ErrorCode::InvalidParameter
        );
        require!(seller_contact.len() <= 200, ErrorCode::InvalidParameter);

        trade.seller_contact = BoundedString::from_option(Some(seller_contact))?;
        trade.state = TradeState::RequestAccepted;
        trade.state_history.push(TradeStateItem {
            actor: ctx.accounts.seller.key(),
            state: TradeState::RequestAccepted,
            timestamp: clock.unix_timestamp,
        })?;

        // Emit trade state change event
        emit!(TradeStateChangeEvent {
            trade_id: trade.id,
            old_state: "RequestCreated".to_string(),
            new_state: format!("{:?}", TradeState::RequestAccepted),
            actor: ctx.accounts.seller.key(),
            timestamp: clock.unix_timestamp,
            trade_index: trade.id,
        });

        Ok(())
    }

    pub fn fund_escrow(ctx: Context<FundEscrow>) -> Result<()> {
        // CIRCUIT BREAKER: Check if deposits are paused
        require_not_paused!(&ctx.accounts.hub_config, Operation::FundEscrow);

        let trade = &mut ctx.accounts.trade;
        let clock = Clock::get()?;

        // COMPREHENSIVE AUTHORIZATION: Validate seller authorization
        validate_comprehensive_authorization(
            &ctx.accounts.seller.key(),
            trade,
            AuthorizationRole::Seller,
        )?;

        // ADVANCED STATE VALIDATION: Validate state transition
        validate_state_transition(
            &trade.state,
            &TradeState::EscrowFunded,
            &ctx.accounts.seller.key(),
            trade,
            clock.unix_timestamp as u64,
        )?;

        // SECURITY: Validate trade hasn't expired
        require!(
            clock.unix_timestamp as u64 <= trade.expires_at,
            ErrorCode::TradeExpired
        );

        // SECURITY: Validate token program before transfer
        validate_token_interface_program(&ctx.accounts.token_program.to_account_info())?;

        // SECURITY: Validate token transfer amount matches trade amount
        let cpi_accounts = TransferChecked {
            from: ctx.accounts.seller_token_account.to_account_info(),
            to: ctx.accounts.escrow_token_account.to_account_info(),
            authority: ctx.accounts.seller.to_account_info(),
            mint: ctx.accounts.token_mint.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

        transfer_checked(cpi_ctx, trade.amount, ctx.accounts.token_mint.decimals)?;

        trade.state = TradeState::EscrowFunded;
        trade.state_history.push(TradeStateItem {
            actor: ctx.accounts.seller.key(),
            state: TradeState::EscrowFunded,
            timestamp: clock.unix_timestamp,
        })?;

        // Emit escrow funded event
        emit!(EscrowFundedEvent {
            trade_id: trade.id,
            seller: ctx.accounts.seller.key(),
            amount: trade.amount,
            escrow_account: ctx.accounts.escrow_token_account.key(),
            timestamp: clock.unix_timestamp,
            trade_index: trade.id,
        });

        Ok(())
    }

    pub fn mark_fiat_deposited(ctx: Context<MarkFiatDeposited>) -> Result<()> {
        let trade = &mut ctx.accounts.trade;
        let clock = Clock::get()?;

        // COMPREHENSIVE AUTHORIZATION: Validate buyer authorization
        validate_comprehensive_authorization(
            &ctx.accounts.buyer.key(),
            trade,
            AuthorizationRole::Buyer,
        )?;

        // ADVANCED STATE VALIDATION: Validate state transition
        validate_state_transition(
            &trade.state,
            &TradeState::FiatDeposited,
            &ctx.accounts.buyer.key(),
            trade,
            clock.unix_timestamp as u64,
        )?;

        // CONFIGURABLE TIMER: Set dispute window based on hub config
        let hub_config = &ctx.accounts.hub_config;
        trade.state = TradeState::FiatDeposited;
        trade.dispute_window_at =
            Some((clock.unix_timestamp as u64).safe_add(hub_config.trade_dispute_timer)?);
        trade.state_history.push(TradeStateItem {
            actor: ctx.accounts.buyer.key(),
            state: TradeState::FiatDeposited,
            timestamp: clock.unix_timestamp,
        })?;

        Ok(())
    }

    /// ADVANCED FEE MANAGEMENT: Enhanced release_escrow with multi-destination fee distribution
    /// Matches CosmWasm pattern for complex fee distribution and LOCAL token burn
    pub fn release_escrow(ctx: Context<ReleaseEscrow>) -> Result<()> {
        // CIRCUIT BREAKER: Check if withdrawals are paused
        require_not_paused!(&ctx.accounts.hub_config, Operation::Withdraw);

        let clock = Clock::get()?;

        // COMPREHENSIVE VALIDATION: State and authorization checks
        {
            let trade = &ctx.accounts.trade;
            require!(
                trade.state == TradeState::FiatDeposited,
                ErrorCode::InvalidTradeState
            );
            require!(
                trade.seller == ctx.accounts.seller.key(),
                ErrorCode::Unauthorized
            );
        }

        // SECURITY: Validate all fee recipient ATAs before any transfers
        // This prevents fund theft through malicious account substitution
        validate_fee_recipient_atas(
            &ctx.accounts.treasury_token_account,
            &ctx.accounts.chain_fee_token_account,
            &ctx.accounts.warchest_token_account,
            &ctx.accounts.burn_reserve_account,
            &ctx.accounts.hub_config,
            &ctx.accounts.token_mint.key(),
        )?;

        // SECURITY: Validate buyer token account
        validate_buyer_token_account(
            &ctx.accounts.buyer_token_account.to_account_info(),
            &ctx.accounts.buyer.key(),
            &ctx.accounts.token_mint.key(),
        )?;

        // Extract needed values to reduce stack usage
        let trade_amount = ctx.accounts.trade.amount;
        let trade_id = ctx.accounts.trade.id;
        let trade_bump = ctx.accounts.trade.bump;
        let token_mint_key = ctx.accounts.token_mint.key();
        let token_decimals = ctx.accounts.token_mint.decimals;
        let seller_key = ctx.accounts.seller.key();

        // DYNAMIC FEE CALCULATION: Use boxed fee info to reduce stack usage
        let fee_info = Box::new(calculate_dynamic_fees(
            trade_amount,
            &token_mint_key,
            &ctx.accounts.hub_config,
            Some(&ctx.accounts.trade),
            Some(&ctx.accounts.offer),
            FeeCalculationMethod::Dynamic,
        )?);

        // Validate calculated fees
        fee_info.validate()?;

        let net_amount = trade_amount
            .checked_sub(fee_info.total_fees())
            .ok_or(ErrorCode::ArithmeticError)?;

        // SIGNER SEEDS: Prepare trade authority seeds
        let trade_id_bytes = trade_id.to_le_bytes();
        let trade_seeds = &[b"trade".as_ref(), trade_id_bytes.as_ref(), &[trade_bump]];
        let signer_seeds = &[&trade_seeds[..]];

        // SECURITY: Validate token program before transfer
        validate_token_interface_program(&ctx.accounts.token_program.to_account_info())?;

        // TRANSFER NET AMOUNT: Send net amount to buyer
        let cpi_accounts = TransferChecked {
            from: ctx.accounts.escrow_token_account.to_account_info(),
            to: ctx.accounts.buyer_token_account.to_account_info(),
            authority: ctx.accounts.trade.to_account_info(),
            mint: ctx.accounts.token_mint.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        transfer_checked(cpi_ctx, net_amount, token_decimals)?;

        // MULTI-DESTINATION FEE DISTRIBUTION: Execute comprehensive fee distribution
        execute_multi_destination_fee_distribution(&ctx, &fee_info, signer_seeds)?;

        // UPDATE TRADE STATE: Mark as released
        let trade = &mut ctx.accounts.trade;
        trade.state = TradeState::EscrowReleased;
        trade.state_history.push(TradeStateItem {
            actor: seller_key,
            state: TradeState::EscrowReleased,
            timestamp: clock.unix_timestamp,
        })?;

        // PROFILE UPDATES: Update both buyer and seller profiles
        // Validate CPI target against hub configuration
        validate_cpi_call_security(
            &ctx.accounts.profile_program.key(),
            &ctx.accounts.hub_config.profile_program,
            &[1u8],
        )?;

        let cpi_program = ctx.accounts.profile_program.to_account_info();

        // Update buyer profile (authorized by seller signer in this instruction)
        let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
            profile: ctx.accounts.buyer_profile.to_account_info(),
            actor: ctx.accounts.seller.to_account_info(),
            buyer: ctx.accounts.buyer.to_account_info(),
            seller: ctx.accounts.seller.to_account_info(),
            arbitrator: ctx.accounts.arbitrator.to_account_info(),
        };
        let cpi_ctx = ValidatedCpiContext::new(
            cpi_program.clone(),
            cpi_accounts,
            &ctx.accounts.hub_config.profile_program,
        )?;
        profile::cpi::update_trade_stats(cpi_ctx.into_inner(), TradeState::EscrowReleased)?;

        // Update seller profile
        let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
            profile: ctx.accounts.seller_profile.to_account_info(),
            actor: ctx.accounts.seller.to_account_info(),
            buyer: ctx.accounts.buyer.to_account_info(),
            seller: ctx.accounts.seller.to_account_info(),
            arbitrator: ctx.accounts.arbitrator.to_account_info(),
        };
        let cpi_ctx = ValidatedCpiContext::new(
            cpi_program,
            cpi_accounts,
            &ctx.accounts.hub_config.profile_program,
        )?;
        profile::cpi::update_trade_stats(cpi_ctx.into_inner(), TradeState::EscrowReleased)?;

        // Emit fee distribution event
        emit!(FeeDistributionEvent {
            trade_id: trade_id,
            total_amount: trade_amount,
            treasury_fee: 0, // Not available in current FeeInfo
            chain_fee: fee_info.chain_amount,
            warchest_fee: fee_info.warchest_amount,
            burn_amount: fee_info.burn_amount,
            net_to_recipient: net_amount,
            timestamp: clock.unix_timestamp,
        });

        // Emit trade completion event
        emit!(TradeCompletedEvent {
            trade_id: trade_id,
            buyer: ctx.accounts.buyer.key(),
            seller: seller_key,
            final_amount: net_amount,
            fees_collected: fee_info.total_fees(),
            completion_type: "normal".to_string(),
            timestamp: clock.unix_timestamp,
            trade_index: trade_id,
        });

        Ok(())
    }

    pub fn cancel_request(ctx: Context<CancelRequest>) -> Result<()> {
        let trade = &mut ctx.accounts.trade;
        let clock = Clock::get()?;

        require!(
            trade.state == TradeState::RequestCreated || trade.state == TradeState::RequestAccepted,
            ErrorCode::InvalidTradeState
        );
        require!(
            trade.buyer == ctx.accounts.user.key() || trade.seller == ctx.accounts.user.key(),
            ErrorCode::Unauthorized
        );

        trade.state = TradeState::RequestCanceled;
        trade.state_history.push(TradeStateItem {
            actor: ctx.accounts.user.key(),
            state: TradeState::RequestCanceled,
            timestamp: clock.unix_timestamp,
        })?;

        Ok(())
    }

    // Arbitrator Management Functions
    pub fn register_arbitrator(
        ctx: Context<RegisterArbitrator>,
        fiat_currency: FiatCurrency,
    ) -> Result<()> {
        // Validate rent exemption before registration
        ctx.accounts.validate_rent_exemption()?;

        let clock = Clock::get()?;

        // Validate admin authority
        require!(
            ctx.accounts.hub_config.authority == ctx.accounts.authority.key(),
            ErrorCode::Unauthorized
        );

        // Initialize or update arbitrator pool
        let arbitrator_pool = &mut ctx.accounts.arbitrator_pool;
        if arbitrator_pool.total_arbitrators == 0 {
            arbitrator_pool.fiat_currency = fiat_currency.clone();
            arbitrator_pool.authority = ctx.accounts.hub_config.authority;
            arbitrator_pool.bump = ctx.bumps.arbitrator_pool;
        }

        // Check if arbitrator already exists
        let arbitrator_pubkey = ctx.accounts.arbitrator.key();
        require!(
            !true /* TODO: Check across paginated arbitrator pages */,
            ErrorCode::ArbitratorAlreadyExists
        );

        // Add arbitrator to pool (max 32 arbitrators)
        require!(
            arbitrator_pool.total_arbitrators < 32,
            ErrorCode::ArbitratorPoolFull
        );
        arbitrator_pool.total_arbitrators += 1;
        // TODO: Add to appropriate arbitrator page

        // Initialize arbitrator info
        let arbitrator_info = &mut ctx.accounts.arbitrator_info;
        arbitrator_info.arbitrator = arbitrator_pubkey;
        arbitrator_info.fiat_currency = fiat_currency;
        arbitrator_info.total_cases = 0;
        arbitrator_info.resolved_cases = 0;
        arbitrator_info.reputation_score = 5000; // Start with 50% (5000 basis points)
        arbitrator_info.registration_date = clock.unix_timestamp;
        arbitrator_info.is_active = true;
        arbitrator_info.bump = ctx.bumps.arbitrator_info;

        Ok(())
    }

    pub fn deactivate_arbitrator(
        ctx: Context<DeactivateArbitrator>,
        _fiat_currency: FiatCurrency,
    ) -> Result<()> {
        // Validate admin authority
        require!(
            ctx.accounts.hub_config.authority == ctx.accounts.authority.key(),
            ErrorCode::Unauthorized
        );

        // Remove arbitrator from pool
        let arbitrator_pool = &mut ctx.accounts.arbitrator_pool;
        let arbitrator_pubkey = ctx.accounts.arbitrator.key();

        // TODO: Find and remove from paginated arbitrator pages
        if arbitrator_pool.total_arbitrators > 0 {
            arbitrator_pool.total_arbitrators -= 1;
        }

        // Mark arbitrator as inactive
        let arbitrator_info = &mut ctx.accounts.arbitrator_info;
        arbitrator_info.is_active = false;

        Ok(())
    }

    // Simplified Arbitrator Assignment Functions (VRF removed due to dependency conflicts)
    pub fn assign_arbitrator(ctx: Context<AssignArbitrator>, trade_id: u64) -> Result<()> {
        // Validate trade exists and is in correct state
        let trade = &mut ctx.accounts.trade;
        require!(
            trade.state == TradeState::RequestCreated,
            ErrorCode::InvalidTradeState
        );

        // Get arbitrator pool for this trade's fiat currency
        let arbitrator_pool = &ctx.accounts.arbitrator_pool;
        require!(
            !arbitrator_pool.total_arbitrators == 0,
            ErrorCode::NoArbitratorsAvailable
        );

        // Use simple deterministic selection based on trade_id for now
        // TODO: Replace with proper VRF once dependency issues are resolved
        let clock = Clock::get()?;
        let pseudo_random = (trade_id.wrapping_add(clock.unix_timestamp as u64)) as usize;
        let random_index = pseudo_random % 100; // 0-99 range

        // Select arbitrator using CosmWasm algorithm
        let selected_arbitrator = select_arbitrator_from_pool(arbitrator_pool, random_index)?;

        // Update trade with selected arbitrator
        trade.arbitrator = selected_arbitrator;

        Ok(())
    }

    // Commit-reveal based arbitrator selection functions
    pub fn commit_randomness(
        ctx: Context<CommitRandomness>,
        trade_id: u64,
        commitment: [u8; 32],
    ) -> Result<()> {
        let commit_reveal = &mut ctx.accounts.commit_reveal;
        let clock = Clock::get()?;
        
        // Initialize if first commit
        if commit_reveal.commits.is_empty() {
            commit_reveal.trade_id = trade_id;
            commit_reveal.reveal_deadline = clock.unix_timestamp + 300; // 5 minutes
            commit_reveal.bump = ctx.bumps.commit_reveal;
        }
        
        // Check if already committed
        require!(
            !commit_reveal.commits.iter().any(|c| c.committer == ctx.accounts.committer.key()),
            ErrorCode::AlreadyCommitted
        );
        
        // Check commit phase hasn't ended
        require!(
            clock.unix_timestamp < commit_reveal.reveal_deadline - 150, // Allow 2.5 min for commits
            ErrorCode::CommitPhaseEnded
        );
        
        // Add commitment
        commit_reveal.commits.push(CommitData {
            committer: ctx.accounts.committer.key(),
            commitment,
            timestamp: clock.unix_timestamp,
        });
        
        emit!(RandomnessCommittedEvent {
            trade_id,
            committer: ctx.accounts.committer.key(),
            commitment: hex::encode(&commitment),
            timestamp: clock.unix_timestamp,
        });
        
        Ok(())
    }

    pub fn reveal_randomness(
        ctx: Context<RevealRandomness>,
        value: [u8; 32],
        nonce: [u8; 32],
    ) -> Result<()> {
        let commit_reveal = &mut ctx.accounts.commit_reveal;
        let clock = Clock::get()?;
        
        // Check we're in reveal phase
        require!(
            clock.unix_timestamp >= commit_reveal.reveal_deadline - 150 &&
            clock.unix_timestamp <= commit_reveal.reveal_deadline,
            ErrorCode::NotInRevealPhase
        );
        
        // Find matching commitment
        let commitment_hash = anchor_lang::solana_program::keccak::hash(&[&value[..], &nonce[..]].concat());
        let commitment_found = commit_reveal.commits.iter()
            .any(|c| c.committer == ctx.accounts.revealer.key() && c.commitment == commitment_hash.to_bytes());
        
        require!(commitment_found, ErrorCode::NoCommitmentFound);
        
        // Add reveal
        commit_reveal.reveals.push(RevealData {
            revealer: ctx.accounts.revealer.key(),
            value,
            nonce,
        });
        
        // If enough reveals, generate final seed and select arbitrator
        if commit_reveal.reveals.len() >= 3 { // Minimum 3 reveals required
            let mut combined_randomness = [0u8; 32];
            for (i, reveal) in commit_reveal.reveals.iter().enumerate() {
                for j in 0..32 {
                    combined_randomness[j] ^= reveal.value[j];
                }
                if i >= 2 { break; } // Use first 3 reveals
            }
            
            commit_reveal.final_seed = Some(combined_randomness);
            
            // Select weighted arbitrator using the combined randomness
            let selected = select_weighted_arbitrator(
                &combined_randomness,
                &ctx.accounts.arbitrator_pool,
                &ctx.remaining_accounts,
            )?;
            
            // Update trade
            let trade = &mut ctx.accounts.trade;
            trade.arbitrator = selected;
            
            emit!(ArbitratorSelectedEvent {
                trade_id: commit_reveal.trade_id,
                arbitrator: selected,
                randomness: hex::encode(&combined_randomness),
                timestamp: clock.unix_timestamp,
            });
        }
        
        Ok(())
    }

    // Enhanced weighted arbitrator selection using improved randomness
    pub fn select_weighted_arbitrator_enhanced(
        ctx: Context<SelectWeightedArbitrator>,
        trade_id: u64,
    ) -> Result<()> {
        let arbitrator_pool = &ctx.accounts.arbitrator_pool;
        let clock = Clock::get()?;
        
        // Generate improved pseudo-randomness using multiple sources
        let mut randomness_sources = Vec::new();
        randomness_sources.extend_from_slice(&trade_id.to_le_bytes());
        randomness_sources.extend_from_slice(&clock.unix_timestamp.to_le_bytes());
        randomness_sources.extend_from_slice(&clock.slot.to_le_bytes());
        
        // Add some recent blockhash entropy if available
        let recent_blockhash = ctx.accounts.recent_blockhashes.data.borrow();
        if recent_blockhash.len() >= 32 {
            randomness_sources.extend_from_slice(&recent_blockhash[0..8]);
        }
        
        let randomness_hash = anchor_lang::solana_program::keccak::hash(&randomness_sources);
        let randomness = randomness_hash.to_bytes();
        
        // Select weighted arbitrator
        let selected = select_weighted_arbitrator(
            &randomness,
            arbitrator_pool,
            &ctx.remaining_accounts,
        )?;
        
        // Update trade
        let trade = &mut ctx.accounts.trade;
        trade.arbitrator = selected;
        
        emit!(ArbitratorSelectedEvent {
            trade_id,
            arbitrator: selected,
            randomness: hex::encode(&randomness),
            timestamp: clock.unix_timestamp,
        });
        
        Ok(())
    }

    // Rename original function to fallback
    pub fn assign_arbitrator_fallback(ctx: Context<AssignArbitrator>, trade_id: u64) -> Result<()> {
        // Validate trade exists and is in correct state
        let trade = &mut ctx.accounts.trade;
        require!(
            trade.state == TradeState::RequestCreated,
            ErrorCode::InvalidTradeState
        );

        // Get arbitrator pool for this trade's fiat currency
        let arbitrator_pool = &ctx.accounts.arbitrator_pool;
        require!(
            !arbitrator_pool.total_arbitrators == 0,
            ErrorCode::NoArbitratorsAvailable
        );

        // Use simple deterministic selection based on trade_id for now
        // Fallback method for when VRF is unavailable
        let clock = Clock::get()?;
        let pseudo_random = (trade_id.wrapping_add(clock.unix_timestamp as u64)) as usize;
        let random_index = pseudo_random % 100; // 0-99 range

        // Select arbitrator using CosmWasm algorithm
        let selected_arbitrator = select_arbitrator_from_pool(arbitrator_pool, random_index)?;

        // Update trade with selected arbitrator
        trade.arbitrator = selected_arbitrator;

        Ok(())
    }

    // Dispute Initiation and Resolution Functions
    pub fn initiate_dispute(
        ctx: Context<InitiateDispute>,
        buyer_contact: String,
        seller_contact: String,
    ) -> Result<()> {
        let clock = Clock::get()?;
        let user = ctx.accounts.user.key();
        let current_time = clock.unix_timestamp as u64;
        
        // Extract trade values to reduce stack usage
        let (trade_buyer, trade_seller, trade_state, dispute_window_at) = {
            let trade = &ctx.accounts.trade;
            (trade.buyer, trade.seller, trade.state.clone(), trade.dispute_window_at)
        };
        
        // CRITICAL: Only buyer or seller can start dispute
        require!(
            user == trade_buyer || user == trade_seller,
            ErrorCode::Unauthorized
        );

        // CRITICAL: Validate state transition
        require!(
            trade_state == TradeState::FiatDeposited,
            ErrorCode::InvalidTradeState
        );

        // CRITICAL: Respect dispute timing window
        let dispute_window_at = dispute_window_at
            .ok_or(ErrorCode::DisputeWindowNotOpen)?;

        require!(
            current_time >= dispute_window_at,
            ErrorCode::PrematureDisputeRequest
        );

        // Update trade state and store contact info for arbitrator
        let trade = &mut ctx.accounts.trade;
        trade.state = TradeState::EscrowDisputed;
        trade.buyer_contact = BoundedString::from_option(Some(buyer_contact))?;
        trade.seller_contact = BoundedString::from_option(Some(seller_contact))?;
        trade.state_history.push(TradeStateItem {
            actor: user,
            state: TradeState::EscrowDisputed,
            timestamp: current_time as i64,
        })?;

        // Update profile stats via CPI
        let cpi_program = ctx.accounts.profile_program.to_account_info();

        // Update buyer profile (authorized by user signer)
        let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
            profile: ctx.accounts.buyer_profile.to_account_info(),
            actor: ctx.accounts.user.to_account_info(),
            buyer: ctx.accounts.buyer.to_account_info(),
            seller: ctx.accounts.seller.to_account_info(),
            arbitrator: ctx.accounts.arbitrator.to_account_info(),
        };
        let cpi_ctx = ValidatedCpiContext::new(
            cpi_program.clone(),
            cpi_accounts,
            &ctx.accounts.hub_config.profile_program,
        )?;
        profile::cpi::update_trade_stats(cpi_ctx.into_inner(), TradeState::EscrowDisputed)?;

        // Update seller profile (authorized by user signer)
        let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
            profile: ctx.accounts.seller_profile.to_account_info(),
            actor: ctx.accounts.user.to_account_info(),
            buyer: ctx.accounts.buyer.to_account_info(),
            seller: ctx.accounts.seller.to_account_info(),
            arbitrator: ctx.accounts.arbitrator.to_account_info(),
        };
        let cpi_ctx = ValidatedCpiContext::new(
            cpi_program,
            cpi_accounts,
            &ctx.accounts.hub_config.profile_program,
        )?;
        profile::cpi::update_trade_stats(cpi_ctx.into_inner(), TradeState::EscrowDisputed)?;

        Ok(())
    }

    /// ENHANCED SETTLE DISPUTE: Enhanced arbitration with multi-destination fee distribution
    /// Matches CosmWasm pattern for complex fee distribution and LOCAL token burn
    pub fn settle_dispute(ctx: Context<SettleDispute>, winner: Pubkey) -> Result<()> {
        let clock = Clock::get()?;

        // COMPREHENSIVE VALIDATION: State and authorization checks
        {
            let trade = &ctx.accounts.trade;

            // SECURITY: Only arbitrator can settle
            require!(
                trade.arbitrator == ctx.accounts.arbitrator.key(),
                ErrorCode::Unauthorized
            );

            // SECURITY: Must be in disputed state
            require!(
                trade.state == TradeState::EscrowDisputed,
                ErrorCode::InvalidTradeState
            );

            // CRITICAL: Winner must be maker or taker (not arbitrary address)
            require!(
                winner == trade.buyer || winner == trade.seller,
                ErrorCode::InvalidWinner
            );

            // ENHANCED VALIDATION: Validate hub config addresses match accounts
            let hub_config = &ctx.accounts.hub_config;
            require!(
                ctx.accounts.treasury.key() == hub_config.treasury,
                ErrorCode::InvalidTreasuryAddress
            );
            require!(
                ctx.accounts.chain_fee_collector.key()
                    == hub_config.chain_fee_collector,
                ErrorCode::InvalidChainFeeCollector
            );
            require!(
                ctx.accounts.warchest.key() == hub_config.warchest_address,
                ErrorCode::InvalidWarchestAddress
            );
        }

        // SECURITY: Validate all dispute settlement accounts before any transfers
        // This prevents fund theft through malicious account substitution
        validate_dispute_accounts(
            &ctx.accounts.winner_token_account,
            &ctx.accounts.arbitrator_token_account,
            &ctx.accounts.treasury_token_account,
            &ctx.accounts.chain_fee_token_account,
            &ctx.accounts.warchest_token_account,
            &ctx.accounts.burn_reserve_account,
            &winner,
            &ctx.accounts.arbitrator.key(),
            &ctx.accounts.hub_config,
            &ctx.accounts.token_mint.key(),
        )?;

        // Extract values to reduce stack usage
        let trade_amount = ctx.accounts.trade.amount;
        let trade_id = ctx.accounts.trade.id;
        let trade_bump = ctx.accounts.trade.bump;
        let trade_buyer = ctx.accounts.trade.buyer;
        let trade_seller = ctx.accounts.trade.seller;
        let offer_owner = ctx.accounts.offer.owner;
        let token_mint_key = ctx.accounts.token_mint.key();
        let token_decimals = ctx.accounts.token_mint.decimals;
        let arbitrator_key = ctx.accounts.arbitrator.key();

        // DYNAMIC FEE CALCULATION: Use boxed fee info to reduce stack usage
        let fee_info = Box::new(calculate_dynamic_fees(
            trade_amount,
            &token_mint_key,
            &ctx.accounts.hub_config,
            Some(&ctx.accounts.trade),
            Some(&ctx.accounts.offer),
            FeeCalculationMethod::Dynamic,
        )?);

        // ARBITRATION FEE CALCULATION: Calculate arbitrator fee separately
        let arbitrator_fee_result = calculate_percentage_fees(
            trade_amount,
            &ctx.accounts.hub_config,
            false, // No conversion needed for arbitrator fees
        )?;
        let arbitrator_fee = arbitrator_fee_result.0; // Get burn_amount as the fee

        // Calculate net amount for winner (after all fees)
        let total_fees = fee_info.total_fees().saturating_add(arbitrator_fee);
        let winner_amount = trade_amount.saturating_sub(total_fees);

        // SIGNER SEEDS: Prepare for CPI calls
        let trade_id_bytes = trade_id.to_le_bytes();
        let trade_seeds = &[b"trade".as_ref(), trade_id_bytes.as_ref(), &[trade_bump]];
        let signer_seeds = &[&trade_seeds[..]];

        // SECURITY: Validate token program before transfers
        validate_token_interface_program(&ctx.accounts.token_program.to_account_info())?;

        // Execute transfers
        let cpi_program = ctx.accounts.token_program.to_account_info();

        // WINNER TRANSFER: Transfer net amount to winner
        let cpi_accounts = TransferChecked {
            from: ctx.accounts.escrow_token_account.to_account_info(),
            to: ctx.accounts.winner_token_account.to_account_info(),
            authority: ctx.accounts.trade.to_account_info(),
            mint: ctx.accounts.token_mint.to_account_info(),
        };
        let cpi_ctx = CpiContext::new_with_signer(cpi_program.clone(), cpi_accounts, signer_seeds);
        transfer_checked(cpi_ctx, winner_amount, token_decimals)?;

        // ARBITRATOR FEE TRANSFER: Transfer arbitrator fee
        if arbitrator_fee > 0 {
            let cpi_accounts = TransferChecked {
                from: ctx.accounts.escrow_token_account.to_account_info(),
                to: ctx.accounts.arbitrator_token_account.to_account_info(),
                authority: ctx.accounts.trade.to_account_info(),
                mint: ctx.accounts.token_mint.to_account_info(),
            };
            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);
            transfer_checked(cpi_ctx, arbitrator_fee, token_decimals)?;
        }

        // MULTI-DESTINATION FEE DISTRIBUTION: Execute enhanced fee distribution
        execute_multi_destination_fee_distribution_for_dispute(&ctx, &fee_info, signer_seeds)?;

        // STATE UPDATE: Update trade state based on winner
        let new_state = if winner == trade_buyer && winner == offer_owner {
            TradeState::SettledForMaker
        } else if winner == trade_seller && winner == offer_owner {
            TradeState::SettledForMaker
        } else if winner == trade_buyer {
            TradeState::SettledForTaker
        } else {
            TradeState::SettledForTaker
        };

        let trade = &mut ctx.accounts.trade;
        trade.state = new_state.clone();
        trade.state_history.push(TradeStateItem {
            actor: arbitrator_key,
            state: new_state.clone(),
            timestamp: clock.unix_timestamp,
        })?;

        // ARBITRATOR STATS: Update arbitrator stats
        let arbitrator_info = &mut ctx.accounts.arbitrator_info;
        arbitrator_info.resolved_cases = arbitrator_info.resolved_cases.saturating_add(1);

        // PROFILE UPDATES: Update both profiles via CPI (authorized by arbitrator)
        // Validate CPI target against hub configuration
        validate_cpi_call_security(
            &ctx.accounts.profile_program.key(),
            &ctx.accounts.hub_config.profile_program,
            &[2u8],
        )?;

        let cpi_program = ctx.accounts.profile_program.to_account_info();

        // Update buyer profile
        let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
            profile: ctx.accounts.buyer_profile.to_account_info(),
            actor: ctx.accounts.arbitrator.to_account_info(),
            buyer: ctx.accounts.buyer.to_account_info(),
            seller: ctx.accounts.seller.to_account_info(),
            arbitrator: ctx.accounts.arbitrator.to_account_info(),
        };
        let cpi_ctx = ValidatedCpiContext::new(
            cpi_program.clone(),
            cpi_accounts,
            &ctx.accounts.hub_config.profile_program,
        )?;
        profile::cpi::update_trade_stats(cpi_ctx.into_inner(), new_state.clone())?;

        // Update seller profile
        let cpi_accounts = profile::cpi::accounts::UpdateTradeStats {
            profile: ctx.accounts.seller_profile.to_account_info(),
            actor: ctx.accounts.arbitrator.to_account_info(),
            buyer: ctx.accounts.buyer.to_account_info(),
            seller: ctx.accounts.seller.to_account_info(),
            arbitrator: ctx.accounts.arbitrator.to_account_info(),
        };
        let cpi_ctx = ValidatedCpiContext::new(
            cpi_program,
            cpi_accounts,
            &ctx.accounts.hub_config.profile_program,
        )?;
        profile::cpi::update_trade_stats(cpi_ctx.into_inner(), new_state.clone())?;

        // Emit dispute resolved event
        emit!(DisputeResolvedEvent {
            trade_id: trade_id,
            arbitrator: arbitrator_key,
            winner: winner,
            resolution_reason: format!("{:?}", new_state),
            fee_to_arbitrator: arbitrator_fee,
            timestamp: clock.unix_timestamp,
            arbitrator_index: arbitrator_key,
        });

        Ok(())
    }

    /// Automatic refund mechanism for expired trades
    pub fn automatic_refund(ctx: Context<AutomaticRefund>) -> Result<()> {
        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp as u64;

        // Get values we need before any mutable borrows
        let trade_id;
        let trade_amount;
        let trade_bump;
        let trade_account_info = ctx.accounts.trade.to_account_info();

        // Scope for validation with mutable borrow
        {
            let trade = &mut ctx.accounts.trade;

            // COMPREHENSIVE VALIDATION: Execute automatic refund validation
            execute_automatic_refund(trade, current_timestamp, &ctx.accounts.caller.key())?;

            // ADVANCED STATE VALIDATION: Validate state transition to refunded
            validate_state_transition(
                &trade.state,
                &TradeState::EscrowRefunded,
                &ctx.accounts.caller.key(),
                trade,
                current_timestamp,
            )?;

            // Get values from trade
            trade_id = trade.id;
            trade_amount = trade.amount;
            trade_bump = trade.bump;
        }

        // SECURITY: Validate seller token account before refund
        // This prevents fund theft through malicious account substitution
        validate_seller_token_account(
            &ctx.accounts.seller_token_account.to_account_info(),
            &ctx.accounts.seller.key(),
            &ctx.accounts.token_mint.key(),
        )?;

        // Prepare signer seeds for trade authority
        let trade_id_bytes = trade_id.to_le_bytes();
        let trade_seeds = &[b"trade".as_ref(), trade_id_bytes.as_ref(), &[trade_bump]];
        let signer_seeds = &[&trade_seeds[..]];

        // SECURITY: Validate token program before refund
        validate_token_interface_program(&ctx.accounts.token_program.to_account_info())?;

        // Transfer funds back to seller
        let cpi_accounts = TransferChecked {
            from: ctx.accounts.escrow_token_account.to_account_info(),
            to: ctx.accounts.seller_token_account.to_account_info(),
            authority: trade_account_info,
            mint: ctx.accounts.token_mint.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        transfer_checked(cpi_ctx, trade_amount, ctx.accounts.token_mint.decimals)?;

        // Update trade state with new mutable borrow
        let trade = &mut ctx.accounts.trade;
        trade.state = TradeState::EscrowRefunded;
        trade.state_history.push(TradeStateItem {
            actor: ctx.accounts.caller.key(),
            state: TradeState::EscrowRefunded,
            timestamp: current_timestamp as i64,
        })?;

        Ok(())
    }
}

// Account contexts
#[derive(Accounts)]
#[instruction(params: CreateTradeParams)]
pub struct CreateTrade<'info> {
    #[account(
        init,
        payer = buyer,
        space = Trade::SPACE,
        seeds = [b"trade".as_ref(), params.trade_id.to_le_bytes().as_ref()],
        bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        seeds::program = hub::ID,
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    /// CHECK: Offer account, validated and deserialized in handler
    pub offer: UncheckedAccount<'info>,

    #[account(
        mut,
        seeds = [b"profile".as_ref(), buyer.key().as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    /// CHECK: Profile account, validated in handler when CPI enabled
    pub buyer_profile: UncheckedAccount<'info>,

    pub token_mint: InterfaceAccount<'info, Mint>,

    #[account(mut)]
    pub buyer: Signer<'info>,

    /// CHECK: Seller wallet must match offer.owner (validated in handler)
    pub seller: UncheckedAccount<'info>,

    /// CHECK: Profile program for CPI call
    pub profile_program: UncheckedAccount<'info>,

    /// CHECK: Price program for USD conversion validation
    pub price_program: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}

impl<'info> RentValidation for CreateTrade<'info> {
    fn validate_rent_exemption(&self) -> Result<()> {
        // Calculate required rent with 10% margin (1000 basis points)
        let required_rent = calculate_rent_with_margin(Trade::SPACE, 1000)?;

        // Ensure payer has sufficient balance
        require!(
            self.buyer.lamports() >= required_rent,
            RentError::InsufficientFunds
        );

        Ok(())
    }
}

#[derive(Accounts)]
pub struct AcceptRequest<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    pub seller: Signer<'info>,
}

#[derive(Accounts)]
pub struct FundEscrow<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        seeds::program = hub::ID,
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(
        init,
        payer = seller,
        seeds = [b"trade".as_ref(), b"escrow".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = trade,
        token::token_program = token_program
    )]
    pub escrow_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = seller,
        associated_token::token_program = token_program,
    )]
    pub seller_token_account: InterfaceAccount<'info, TokenAccount>,

    pub token_mint: InterfaceAccount<'info, Mint>,

    #[account(mut)]
    pub seller: Signer<'info>,

    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct MarkFiatDeposited<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        seeds::program = hub::ID,
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    pub buyer: Signer<'info>,

    /// CHECK: Seller wallet must match trade.seller
    #[account(constraint = seller.key() == trade.seller @ ErrorCode::Unauthorized)]
    pub seller: UncheckedAccount<'info>,

    /// CHECK: Arbitrator for this trade
    #[account(constraint = arbitrator.key() == trade.arbitrator @ ErrorCode::Unauthorized)]
    pub arbitrator: UncheckedAccount<'info>,
}

/// ENHANCED RELEASE ESCROW: Account context for multi-destination fee distribution
#[derive(Accounts)]
pub struct ReleaseEscrow<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        seeds = [b"offer".as_ref(), trade.offer_id.to_le_bytes().as_ref()],
        bump,
        seeds::program = offer::ID
    )]
    pub offer: Account<'info, offer::Offer>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        seeds::program = hub::ID,
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(
        mut,
        seeds = [b"trade".as_ref(), b"escrow".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = trade,
        token::token_program = token_program
    )]
    pub escrow_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = buyer,
        associated_token::token_program = token_program,
    )]
    pub buyer_token_account: InterfaceAccount<'info, TokenAccount>,

    // MULTI-DESTINATION FEE ACCOUNTS: Provided as unchecked to reduce stack size; validated at runtime
    /// CHECK: Treasury ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub treasury_token_account: UncheckedAccount<'info>,

    /// CHECK: Chain fee collector ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub chain_fee_token_account: UncheckedAccount<'info>,

    /// CHECK: Warchest ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub warchest_token_account: UncheckedAccount<'info>,

    /// CHECK: Burn reserve ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub burn_reserve_account: UncheckedAccount<'info>,

    // PROFILE ACCOUNTS: For CPI updates
    #[account(
        mut,
        seeds = [b"profile".as_ref(), buyer.key().as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    pub buyer_profile: Account<'info, profile::Profile>,

    #[account(
        mut,
        seeds = [b"profile".as_ref(), seller.key().as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    pub seller_profile: Account<'info, profile::Profile>,

    // TOKEN AND WALLET ACCOUNTS
    pub token_mint: InterfaceAccount<'info, Mint>,

    /// CHECK: Treasury wallet - validated against hub_config
    #[account(constraint = treasury.key() == hub_config.treasury @ ErrorCode::InvalidTreasuryAddress)]
    pub treasury: UncheckedAccount<'info>,
    /// CHECK: Chain fee collector - validated against hub_config
    #[account(constraint = chain_fee_collector.key() == hub_config.chain_fee_collector @ ErrorCode::InvalidChainFeeCollector)]
    pub chain_fee_collector: UncheckedAccount<'info>,
    /// CHECK: Warchest address - validated against hub_config
    #[account(constraint = warchest.key() == hub_config.warchest_address @ ErrorCode::InvalidWarchestAddress)]
    pub warchest: UncheckedAccount<'info>,
    /// CHECK: Burn reserve for non-LOCAL token conversion
    pub burn_reserve: UncheckedAccount<'info>,
    /// CHECK: Buyer wallet (must match trade.buyer)
    #[account(constraint = buyer.key() == trade.buyer @ ErrorCode::Unauthorized)]
    pub buyer: UncheckedAccount<'info>,
    pub seller: Signer<'info>,

    /// CHECK: Arbitrator for this trade
    #[account(constraint = arbitrator.key() == trade.arbitrator @ ErrorCode::Unauthorized)]
    pub arbitrator: UncheckedAccount<'info>,

    // PROGRAM ACCOUNTS
    /// Profile program for CPI call
    pub profile_program: Program<'info, profile::program::Profile>,

    pub token_program: Interface<'info, TokenInterface>,
    // associated_token_program removed to reduce account size
}

#[derive(Accounts)]
pub struct CancelRequest<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    pub user: Signer<'info>,
}

#[derive(Accounts)]
#[instruction(fiat_currency: FiatCurrency)]
pub struct RegisterArbitrator<'info> {
    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(
        init_if_needed,
        payer = authority,
        space = ArbitratorPool::SPACE,
        seeds = [b"arbitrator-pool".as_ref(), match fiat_currency {
            FiatCurrency::Usd => b"USD",
            FiatCurrency::Eur => b"EUR",
            FiatCurrency::Gbp => b"GBP",
            FiatCurrency::Cad => b"CAD",
            FiatCurrency::Aud => b"AUD",
            FiatCurrency::Jpy => b"JPY",
            FiatCurrency::Brl => b"BRL",
            FiatCurrency::Mxn => b"MXN",
            FiatCurrency::Ars => b"ARS",
            FiatCurrency::Clp => b"CLP",
            FiatCurrency::Cop => b"COP",
            FiatCurrency::Ngn => b"NGN",
            FiatCurrency::Thb => b"THB",
            FiatCurrency::Ves => b"VES",
        }],
        bump
    )]
    pub arbitrator_pool: Account<'info, ArbitratorPool>,

    #[account(
        init,
        payer = authority,
        space = ArbitratorInfo::SPACE,
        seeds = [b"arbitrator".as_ref(), arbitrator.key().as_ref(), match fiat_currency {
            FiatCurrency::Usd => b"USD",
            FiatCurrency::Eur => b"EUR",
            FiatCurrency::Gbp => b"GBP",
            FiatCurrency::Cad => b"CAD",
            FiatCurrency::Aud => b"AUD",
            FiatCurrency::Jpy => b"JPY",
            FiatCurrency::Brl => b"BRL",
            FiatCurrency::Mxn => b"MXN",
            FiatCurrency::Ars => b"ARS",
            FiatCurrency::Clp => b"CLP",
            FiatCurrency::Cop => b"COP",
            FiatCurrency::Ngn => b"NGN",
            FiatCurrency::Thb => b"THB",
            FiatCurrency::Ves => b"VES",
        }],
        bump
    )]
    pub arbitrator_info: Account<'info, ArbitratorInfo>,

    /// CHECK: Arbitrator wallet to be registered
    pub arbitrator: UncheckedAccount<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

impl<'info> RentValidation for RegisterArbitrator<'info> {
    fn validate_rent_exemption(&self) -> Result<()> {
        // Calculate required rent for ArbitratorInfo with 10% margin
        let required_rent = calculate_rent_with_margin(ArbitratorInfo::SPACE, 1000)?;

        // Ensure payer has sufficient balance
        require!(
            self.authority.lamports() >= required_rent,
            RentError::InsufficientFunds
        );

        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(fiat_currency: FiatCurrency)]
pub struct DeactivateArbitrator<'info> {
    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(
        mut,
        seeds = [b"arbitrator-pool".as_ref(), match fiat_currency {
            FiatCurrency::Usd => b"USD",
            FiatCurrency::Eur => b"EUR",
            FiatCurrency::Gbp => b"GBP",
            FiatCurrency::Cad => b"CAD",
            FiatCurrency::Aud => b"AUD",
            FiatCurrency::Jpy => b"JPY",
            FiatCurrency::Brl => b"BRL",
            FiatCurrency::Mxn => b"MXN",
            FiatCurrency::Ars => b"ARS",
            FiatCurrency::Clp => b"CLP",
            FiatCurrency::Cop => b"COP",
            FiatCurrency::Ngn => b"NGN",
            FiatCurrency::Thb => b"THB",
            FiatCurrency::Ves => b"VES",
        }],
        bump
    )]
    pub arbitrator_pool: Account<'info, ArbitratorPool>,

    #[account(
        mut,
        seeds = [b"arbitrator".as_ref(), arbitrator.key().as_ref(), match fiat_currency {
            FiatCurrency::Usd => b"USD",
            FiatCurrency::Eur => b"EUR",
            FiatCurrency::Gbp => b"GBP",
            FiatCurrency::Cad => b"CAD",
            FiatCurrency::Aud => b"AUD",
            FiatCurrency::Jpy => b"JPY",
            FiatCurrency::Brl => b"BRL",
            FiatCurrency::Mxn => b"MXN",
            FiatCurrency::Ars => b"ARS",
            FiatCurrency::Clp => b"CLP",
            FiatCurrency::Cop => b"COP",
            FiatCurrency::Ngn => b"NGN",
            FiatCurrency::Thb => b"THB",
            FiatCurrency::Ves => b"VES",
        }],
        bump
    )]
    pub arbitrator_info: Account<'info, ArbitratorInfo>,

    /// CHECK: Arbitrator wallet to be deactivated
    pub arbitrator: UncheckedAccount<'info>,

    pub authority: Signer<'info>,
}

#[derive(Accounts)]
#[instruction(trade_id: u64)]
pub struct AssignArbitrator<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade_id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        seeds = [b"arbitrator-pool".as_ref(), match trade.fiat_currency {
            FiatCurrency::Usd => b"USD",
            FiatCurrency::Eur => b"EUR",
            FiatCurrency::Gbp => b"GBP",
            FiatCurrency::Cad => b"CAD",
            FiatCurrency::Aud => b"AUD",
            FiatCurrency::Jpy => b"JPY",
            FiatCurrency::Brl => b"BRL",
            FiatCurrency::Mxn => b"MXN",
            FiatCurrency::Ars => b"ARS",
            FiatCurrency::Clp => b"CLP",
            FiatCurrency::Cop => b"COP",
            FiatCurrency::Ngn => b"NGN",
            FiatCurrency::Thb => b"THB",
            FiatCurrency::Ves => b"VES",
        }],
        bump
    )]
    pub arbitrator_pool: Account<'info, ArbitratorPool>,

    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct InitiateDispute<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        mut,
        seeds = [b"profile".as_ref(), trade.buyer.as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    pub buyer_profile: Account<'info, profile::Profile>,

    #[account(
        mut,
        seeds = [b"profile".as_ref(), trade.seller.as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    pub seller_profile: Account<'info, profile::Profile>,

    pub user: Signer<'info>,

    /// Profile program for CPI call
    pub profile_program: Program<'info, profile::program::Profile>,

    /// CHECK: Buyer wallet (must match trade.buyer)
    #[account(constraint = buyer.key() == trade.buyer @ ErrorCode::Unauthorized)]
    pub buyer: UncheckedAccount<'info>,
    /// CHECK: Seller wallet (must match trade.seller)
    #[account(constraint = seller.key() == trade.seller @ ErrorCode::Unauthorized)]
    pub seller: UncheckedAccount<'info>,
    /// CHECK: Arbitrator wallet (must match trade.arbitrator)
    #[account(constraint = arbitrator.key() == trade.arbitrator @ ErrorCode::Unauthorized)]
    pub arbitrator: UncheckedAccount<'info>,

    /// Hub configuration for validating program IDs
    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        seeds::program = hub::ID,
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,
}

/// ENHANCED SETTLE DISPUTE: Account context for multi-destination fee distribution
#[derive(Accounts)]
pub struct SettleDispute<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(
        seeds = [b"offer".as_ref(), trade.offer_id.to_le_bytes().as_ref()],
        bump,
        seeds::program = offer::ID
    )]
    pub offer: Account<'info, offer::Offer>,

    #[account(
        mut,
        seeds = [b"arbitrator".as_ref(), arbitrator.key().as_ref(), match trade.fiat_currency {
            FiatCurrency::Usd => b"USD",
            FiatCurrency::Eur => b"EUR",
            FiatCurrency::Gbp => b"GBP",
            FiatCurrency::Cad => b"CAD",
            FiatCurrency::Aud => b"AUD",
            FiatCurrency::Jpy => b"JPY",
            FiatCurrency::Brl => b"BRL",
            FiatCurrency::Mxn => b"MXN",
            FiatCurrency::Ars => b"ARS",
            FiatCurrency::Clp => b"CLP",
            FiatCurrency::Cop => b"COP",
            FiatCurrency::Ngn => b"NGN",
            FiatCurrency::Thb => b"THB",
            FiatCurrency::Ves => b"VES",
        }],
        bump
    )]
    pub arbitrator_info: Account<'info, ArbitratorInfo>,

    #[account(
        mut,
        seeds = [b"trade".as_ref(), b"escrow".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = trade,
        token::token_program = token_program
    )]
    pub escrow_token_account: InterfaceAccount<'info, TokenAccount>,

    /// CHECK: Winner ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub winner_token_account: UncheckedAccount<'info>,

    /// CHECK: Arbitrator ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub arbitrator_token_account: UncheckedAccount<'info>,

    // MULTI-DESTINATION FEE ACCOUNTS: Provided as unchecked to reduce stack size; validated at runtime
    /// CHECK: Treasury ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub treasury_token_account: UncheckedAccount<'info>,

    /// CHECK: Chain fee collector ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub chain_fee_token_account: UncheckedAccount<'info>,

    /// CHECK: Warchest ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub warchest_token_account: UncheckedAccount<'info>,

    /// CHECK: Burn reserve ATA; validated by deriving expected ATA at runtime
    #[account(mut)]
    pub burn_reserve_account: UncheckedAccount<'info>,

    // PROFILE ACCOUNTS: For CPI updates
    #[account(
        mut,
        seeds = [b"profile".as_ref(), trade.buyer.as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    pub buyer_profile: Account<'info, profile::Profile>,

    #[account(
        mut,
        seeds = [b"profile".as_ref(), trade.seller.as_ref()],
        bump,
        seeds::program = profile::ID
    )]
    pub seller_profile: Account<'info, profile::Profile>,

    // TOKEN AND WALLET ACCOUNTS
    pub token_mint: InterfaceAccount<'info, Mint>,

    /// CHECK: Winner wallet (verified in function logic)
    pub winner: UncheckedAccount<'info>,
    /// CHECK: Treasury wallet - validated against hub_config
    pub treasury: UncheckedAccount<'info>,
    /// CHECK: Chain fee collector - validated against hub_config
    pub chain_fee_collector: UncheckedAccount<'info>,
    /// CHECK: Warchest address - validated against hub_config
    pub warchest: UncheckedAccount<'info>,
    /// CHECK: Burn reserve for non-LOCAL token conversion
    pub burn_reserve: UncheckedAccount<'info>,
    pub arbitrator: Signer<'info>,

    // PROGRAM ACCOUNTS
    /// CHECK: Profile program for CPI call
    pub profile_program: Program<'info, profile::program::Profile>,

    /// CHECK: Buyer wallet (must match trade.buyer)
    #[account(constraint = buyer.key() == trade.buyer @ ErrorCode::Unauthorized)]
    pub buyer: UncheckedAccount<'info>,
    /// CHECK: Seller wallet (must match trade.seller)
    #[account(constraint = seller.key() == trade.seller @ ErrorCode::Unauthorized)]
    pub seller: UncheckedAccount<'info>,

    pub token_program: Interface<'info, TokenInterface>,
    // associated_token_program removed to reduce account size
}

#[derive(Accounts)]
pub struct AutomaticRefund<'info> {
    #[account(
        mut,
        seeds = [b"trade".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        mut,
        seeds = [b"trade".as_ref(), b"escrow".as_ref(), trade.id.to_le_bytes().as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = trade,
        token::token_program = token_program
    )]
    pub escrow_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = seller,
        associated_token::token_program = token_program,
    )]
    pub seller_token_account: InterfaceAccount<'info, TokenAccount>,

    pub token_mint: InterfaceAccount<'info, Mint>,

    /// CHECK: Seller wallet - validated in function logic
    pub seller: UncheckedAccount<'info>,

    /// CHECK: Anyone can trigger automatic refund for expired trades
    pub caller: Signer<'info>,

    pub token_program: Interface<'info, TokenInterface>,
}

/// ADVANCED FEE MANAGEMENT: Account contexts for token conversion system

#[derive(Accounts)]
#[instruction(source_mint: Pubkey, target_mint: Pubkey)]
pub struct RegisterConversionRoute<'info> {
    #[account(
        init,
        payer = authority,
        space = TokenConversionRoute::SPACE,
        seeds = [
            b"conversion_route".as_ref(),
            source_mint.as_ref(),
            target_mint.as_ref()
        ],
        bump
    )]
    pub conversion_route: Account<'info, TokenConversionRoute>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

impl<'info> RentValidation for RegisterConversionRoute<'info> {
    fn validate_rent_exemption(&self) -> Result<()> {
        // Calculate required rent for TokenConversionRoute with 10% margin
        let required_rent = calculate_rent_with_margin(TokenConversionRoute::SPACE, 1000)?;

        // Ensure payer has sufficient balance
        require!(
            self.authority.lamports() >= required_rent,
            RentError::InsufficientFunds
        );

        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(trade_id: u64)]
pub struct InitializeConversion<'info> {
    #[account(
        init,
        payer = authority,
        space = TokenConversionState::SPACE,
        seeds = [
            b"conversion_state".as_ref(),
            trade_id.to_le_bytes().as_ref()
        ],
        bump
    )]
    pub conversion_state: Account<'info, TokenConversionState>,

    #[account(
        seeds = [
            b"conversion_route".as_ref(),
            conversion_route.source_mint.as_ref(),
            conversion_route.target_mint.as_ref()
        ],
        bump = conversion_route.bump
    )]
    pub conversion_route: Account<'info, TokenConversionRoute>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

impl<'info> RentValidation for InitializeConversion<'info> {
    fn validate_rent_exemption(&self) -> Result<()> {
        // Calculate required rent for TokenConversionState with 10% margin
        let required_rent = calculate_rent_with_margin(TokenConversionState::SPACE, 1000)?;

        // Ensure payer has sufficient balance
        require!(
            self.authority.lamports() >= required_rent,
            RentError::InsufficientFunds
        );

        Ok(())
    }
}

#[derive(Accounts)]
pub struct ExecuteConversionStep<'info> {
    #[account(
        mut,
        seeds = [
            b"conversion_state".as_ref(),
            conversion_state.trade_id.to_le_bytes().as_ref()
        ],
        bump = conversion_state.bump
    )]
    pub conversion_state: Account<'info, TokenConversionState>,

    #[account(
        mut,
        seeds = [
            b"conversion_route".as_ref(),
            conversion_route.source_mint.as_ref(),
            conversion_route.target_mint.as_ref()
        ],
        bump = conversion_route.bump
    )]
    pub conversion_route: Account<'info, TokenConversionRoute>,

    #[account(
        seeds = [b"trade".as_ref(), conversion_state.trade_id.to_le_bytes().as_ref()],
        bump
    )]
    pub trade: Account<'info, Trade>,

    #[account(
        mut,
        seeds = [b"trade".as_ref(), b"escrow".as_ref(), conversion_state.trade_id.to_le_bytes().as_ref()],
        bump,
        token::mint = source_token_mint,
        token::authority = trade,
        token::token_program = token_program
    )]
    pub escrow_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(
        mut,
        associated_token::mint = target_token_mint,
        associated_token::authority = trade,
        associated_token::token_program = token_program,
    )]
    pub trade_target_token_account: InterfaceAccount<'info, TokenAccount>,

    pub source_token_mint: InterfaceAccount<'info, Mint>,
    pub target_token_mint: InterfaceAccount<'info, Mint>,

    /// CHECK: Jupiter program for DEX operations
    pub jupiter_program: UncheckedAccount<'info>,

    /// CHECK: Pool address for current conversion step
    pub pool_address: UncheckedAccount<'info>,

    pub authority: Signer<'info>,
    pub token_program: Interface<'info, TokenInterface>,
}

// Data structures
#[account]
#[derive(Debug)]
pub struct Trade {
    pub id: u64,
    pub offer_id: u64,
    pub buyer: Pubkey,
    pub seller: Pubkey,
    pub arbitrator: Pubkey,
    pub token_mint: Pubkey,
    pub amount: u64,
    pub fiat_currency: FiatCurrency,
    pub locked_price: u64,
    pub state: TradeState,
    pub created_at: u64,
    pub expires_at: u64,
    pub dispute_window_at: Option<u64>,
    pub state_history: BoundedStateHistory,
    pub buyer_contact: Option<BoundedString>,
    pub seller_contact: Option<BoundedString>,
    pub bump: u8,
}

impl Trade {
    pub const SPACE: usize = 8 + // discriminator
        8 + // id
        8 + // offer_id
        32 + // buyer
        32 + // seller
        32 + // arbitrator
        32 + // token_mint
        8 + // amount
        1 + // fiat_currency
        8 + // locked_price
        1 + // state
        8 + // created_at
        8 + // expires_at
        9 + // dispute_window_at (Option<u64>)
        BoundedStateHistory::space() + // state_history with circular buffer
        BoundedString::option_space() + // buyer_contact
        BoundedString::option_space() + // seller_contact
        1; // bump
}


#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct CreateTradeParams {
    pub trade_id: u64,
    pub offer_id: u64,
    pub amount: u64,
    pub locked_price: u64,
    pub expiry_duration: u64,
    pub arbitrator: Pubkey,
    pub buyer_contact: String,
}

/// ADVANCED FEE MANAGEMENT: Enhanced fee information with multi-destination support
/// Matches CosmWasm implementation patterns for comprehensive fee distribution
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]
pub struct FeeInfo {
    // MULTI-DESTINATION FEES: Core fee components
    pub burn_amount: u64,     // Amount to burn as LOCAL tokens
    pub chain_amount: u64,    // Amount for chain fee sharing
    pub warchest_amount: u64, // Amount for warchest/treasury

    // TOKEN CONVERSION FEES: Additional fees for non-LOCAL tokens
    pub conversion_fee: u64,   // Fee for DEX conversion operations
    pub slippage_reserve: u64, // Reserve for slippage protection

    // METADATA: Fee calculation context
    pub original_amount: u64,      // Original trade amount before fees
    pub requires_conversion: bool, // Whether token needs to be converted
    pub fee_calculation_method: FeeCalculationMethod, // How fees were calculated
}

impl FeeInfo {
    /// Total fees across all destinations
    pub fn total_fees(&self) -> u64 {
        self.burn_amount
            .saturating_add(self.chain_amount)
            .saturating_add(self.warchest_amount)
            .saturating_add(self.conversion_fee)
            .saturating_add(self.slippage_reserve)
    }

    /// Protocol fees only (excluding conversion fees)
    pub fn protocol_fees(&self) -> u64 {
        self.burn_amount
            .saturating_add(self.chain_amount)
            .saturating_add(self.warchest_amount)
    }

    /// Net amount after all fees
    pub fn net_amount(&self) -> u64 {
        self.original_amount.saturating_sub(self.total_fees())
    }

    /// Validate fee amounts don't exceed original amount
    pub fn validate(&self) -> Result<()> {
        require!(
            self.total_fees() <= self.original_amount,
            ErrorCode::ExcessiveFees
        );

        // Individual fee validation (max 10% each component)
        let max_individual_fee = self.original_amount / 10;

        require!(
            self.burn_amount <= max_individual_fee,
            ErrorCode::ExcessiveBurnFee
        );

        require!(
            self.chain_amount <= max_individual_fee,
            ErrorCode::ExcessiveChainFee
        );

        require!(
            self.warchest_amount <= max_individual_fee,
            ErrorCode::ExcessiveWarchestFee
        );

        require!(
            self.conversion_fee <= max_individual_fee,
            ErrorCode::ExcessiveConversionFee
        );

        Ok(())
    }

    /// Create new FeeInfo with validation
    pub fn new(
        original_amount: u64,
        burn_amount: u64,
        chain_amount: u64,
        warchest_amount: u64,
        conversion_fee: u64,
        slippage_reserve: u64,
        requires_conversion: bool,
        fee_calculation_method: FeeCalculationMethod,
    ) -> Result<Self> {
        let fee_info = Self {
            burn_amount,
            chain_amount,
            warchest_amount,
            conversion_fee,
            slippage_reserve,
            original_amount,
            requires_conversion,
            fee_calculation_method,
        };

        fee_info.validate()?;
        Ok(fee_info)
    }
}

/// ARBITRATION SETTLEMENT: Enhanced fee structure for dispute resolution
/// Includes complex fee distribution matching CosmWasm patterns
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]
pub struct ArbitrationSettlementFees {
    pub winner_amount: u64,  // Amount distributed to dispute winner
    pub arbitrator_fee: u64, // Fee paid to arbitrator
    pub protocol_fee: u64,   // Protocol fees (burn + chain + warchest)

    // ADVANCED ARBITRATION: Additional fee components
    pub conversion_fee: u64,   // Fee for token conversions during settlement
    pub gas_compensation: u64, // Compensation for transaction costs
    pub penalty_fee: u64,      // Penalty fee for frivolous disputes
}

impl ArbitrationSettlementFees {
    pub fn total_distributed(&self) -> u64 {
        self.winner_amount
            .saturating_add(self.arbitrator_fee)
            .saturating_add(self.protocol_fee)
            .saturating_add(self.conversion_fee)
            .saturating_add(self.gas_compensation)
            .saturating_add(self.penalty_fee)
    }

    /// Validate arbitration fees
    pub fn validate(&self, original_amount: u64) -> Result<()> {
        require!(
            self.total_distributed() <= original_amount,
            ErrorCode::ExcessiveArbitrationFees
        );

        // Arbitrator fee should not exceed 10% of trade amount
        require!(
            self.arbitrator_fee <= original_amount / 10,
            ErrorCode::ExcessiveArbitratorFee
        );

        Ok(())
    }
}

/// FEE CALCULATION METHODS: Different approaches for calculating fees
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]
pub enum FeeCalculationMethod {
    /// Standard percentage-based fees
    Percentage,
    /// Dynamic fees based on trade parameters
    Dynamic,
    /// Tiered fees based on amount ranges
    Tiered,
    /// Market maker vs taker differentiated fees
    MakerTaker,
    /// Token-specific fee structure
    TokenSpecific,
}

/// TOKEN CONVERSION: Information about token conversion requirements
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]
pub struct ConversionInfo {
    pub source_mint: Pubkey,                   // Source token mint
    pub requires_conversion: bool,             // Whether conversion is needed
    pub conversion_route: Vec<ConversionStep>, // DEX route for conversion
    pub estimated_slippage: u16,               // Estimated slippage in basis points
    pub min_output_amount: u64,                // Minimum expected output amount
}

/// CONVERSION STEP: Individual step in token conversion route
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]
pub struct ConversionStep {
    pub dex_program: Pubkey,   // DEX program to use (e.g., Jupiter)
    pub input_mint: Pubkey,    // Input token mint
    pub output_mint: Pubkey,   // Output token mint
    pub pool_address: Pubkey,  // Liquidity pool address
    pub estimated_fee: u64,    // Estimated DEX fee
    pub max_slippage_bps: u16, // Maximum allowed slippage
}

/// TOKEN CONVERSION ROUTE SYSTEM: Comprehensive routing for non-LOCAL tokens
/// Matches CosmWasm pattern for DENOM_CONVERSION_ROUTE storage
#[account]
pub struct TokenConversionRoute {
    pub source_mint: Pubkey,              // Source token that needs conversion
    pub target_mint: Pubkey,              // Target token (usually LOCAL)
    pub route_steps: Vec<ConversionStep>, // Sequential DEX operations
    pub total_estimated_fee: u64,         // Sum of all step fees
    pub max_total_slippage_bps: u16,      // Maximum total slippage allowed
    pub route_priority: u8,               // Priority ranking (0 = highest)
    pub is_active: bool,                  // Whether route is currently active
    pub created_at: i64,                  // Route creation timestamp
    pub last_updated: i64,                // Last update timestamp
    pub success_count: u64,               // Number of successful conversions
    pub failure_count: u64,               // Number of failed conversions
    pub authority: Pubkey,                // Authority that can update route
    pub bump: u8,
}

impl TokenConversionRoute {
    pub const SPACE: usize = 8 +      // discriminator
        32 +                          // source_mint
        32 +                          // target_mint
        4 + (6 * 32 + 8 + 2) * 5 +   // route_steps (max 5 steps)
        8 +                           // total_estimated_fee
        2 +                           // max_total_slippage_bps
        1 +                           // route_priority
        1 +                           // is_active
        8 +                           // created_at
        8 +                           // last_updated
        8 +                           // success_count
        8 +                           // failure_count
        32 +                          // authority
        1; // bump

    /// Validate conversion route configuration
    pub fn validate(&self) -> Result<()> {
        // Ensure route has at least one step
        require!(
            !self.route_steps.is_empty(),
            ErrorCode::InvalidConversionRoute
        );

        // Ensure route doesn't exceed maximum complexity
        require!(
            self.route_steps.len() <= 5,
            ErrorCode::ConversionRouteTooComplex
        );

        // Validate step connectivity
        for i in 0..self.route_steps.len() {
            let step = &self.route_steps[i];

            // First step input should match source_mint
            if i == 0 {
                require!(
                    step.input_mint == self.source_mint,
                    ErrorCode::InvalidConversionRoute
                );
            }

            // Last step output should match target_mint
            if i == self.route_steps.len() - 1 {
                require!(
                    step.output_mint == self.target_mint,
                    ErrorCode::InvalidConversionRoute
                );
            }

            // Sequential steps must connect
            if i > 0 {
                require!(
                    step.input_mint == self.route_steps[i - 1].output_mint,
                    ErrorCode::InvalidConversionRoute
                );
            }

            // Validate slippage limits
            require!(
                step.max_slippage_bps <= 1000, // Max 10% slippage per step
                ErrorCode::SlippageExceeded
            );
        }

        // Validate total slippage
        require!(
            self.max_total_slippage_bps <= 2000, // Max 20% total slippage
            ErrorCode::SlippageExceeded
        );

        Ok(())
    }

    /// Calculate route efficiency score
    pub fn efficiency_score(&self) -> u32 {
        if self.success_count + self.failure_count == 0 {
            return 5000; // Default score for new routes
        }

        let success_rate = (self.success_count * 10000) / (self.success_count + self.failure_count);
        let complexity_penalty = (self.route_steps.len() as u64) * 500; // Penalty for complexity
        let slippage_penalty = (self.max_total_slippage_bps as u64) * 2; // Penalty for high slippage

        success_rate
            .saturating_sub(complexity_penalty)
            .saturating_sub(slippage_penalty) as u32
    }

    /// Update route statistics
    pub fn record_success(&mut self) {
        self.success_count = self.success_count.saturating_add(1);
        self.last_updated = Clock::get().unwrap().unix_timestamp;
    }

    pub fn record_failure(&mut self) {
        self.failure_count = self.failure_count.saturating_add(1);
        self.last_updated = Clock::get().unwrap().unix_timestamp;
    }
}

/// TOKEN CONVERSION MANAGER: Manages active conversion state
/// Matches CosmWasm DENOM_CONVERSION_STEP pattern
#[account]
pub struct TokenConversionState {
    pub trade_id: u64,                       // Associated trade ID
    pub source_mint: Pubkey,                 // Source token being converted
    pub target_mint: Pubkey,                 // Target token (LOCAL)
    pub conversion_amount: u64,              // Amount being converted
    pub current_step: u8,                    // Current step in route
    pub route_address: Pubkey,               // Address of conversion route being used
    pub step_start_balance: u64,             // Balance before current step
    pub total_fees_paid: u64,                // Total fees paid so far
    pub slippage_experienced: u16,           // Actual slippage experienced (bps)
    pub conversion_status: ConversionStatus, // Current status
    pub started_at: i64,                     // Conversion start time
    pub authority: Pubkey,                   // Trade account authority
    pub bump: u8,
}

impl TokenConversionState {
    pub const SPACE: usize = 8 +      // discriminator
        8 +                           // trade_id
        32 +                          // source_mint
        32 +                          // target_mint
        8 +                           // conversion_amount
        1 +                           // current_step
        32 +                          // route_address
        8 +                           // step_start_balance
        8 +                           // total_fees_paid
        2 +                           // slippage_experienced
        1 +                           // conversion_status
        8 +                           // started_at
        32 +                          // authority
        1; // bump
}

/// CONVERSION STATUS: Track conversion progress
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]
pub enum ConversionStatus {
    Pending,            // Conversion not started
    InProgress,         // Conversion in progress
    Completed,          // Conversion completed successfully
    Failed,             // Conversion failed
    PartiallyCompleted, // Some steps completed, others failed
}

/// TOKEN CONVERSION FUNCTIONS: Core conversion logic

/// Register a new token conversion route
pub fn register_token_conversion_route(
    ctx: Context<RegisterConversionRoute>,
    source_mint: Pubkey,
    target_mint: Pubkey,
    route_steps: Vec<ConversionStep>,
    max_total_slippage_bps: u16,
    priority: u8,
) -> Result<()> {
    // Validate rent exemption before registration
    ctx.accounts.validate_rent_exemption()?;

    let conversion_route = &mut ctx.accounts.conversion_route;
    let clock = Clock::get()?;

    // Initialize route
    conversion_route.source_mint = source_mint;
    conversion_route.target_mint = target_mint;
    conversion_route.route_steps = route_steps;
    conversion_route.max_total_slippage_bps = max_total_slippage_bps;
    conversion_route.route_priority = priority;
    conversion_route.is_active = true;
    conversion_route.created_at = clock.unix_timestamp;
    conversion_route.last_updated = clock.unix_timestamp;
    conversion_route.success_count = 0;
    conversion_route.failure_count = 0;
    conversion_route.authority = ctx.accounts.authority.key();
    conversion_route.bump = ctx.bumps.conversion_route;

    // Calculate total estimated fee
    conversion_route.total_estimated_fee = conversion_route
        .route_steps
        .iter()
        .map(|step| step.estimated_fee)
        .sum();

    // Validate route configuration
    conversion_route.validate()?;

    Ok(())
}

/// Get optimal conversion route for token pair
pub fn get_optimal_conversion_route<'a>(
    source_mint: &Pubkey,
    target_mint: &Pubkey,
    routes: &'a [TokenConversionRoute],
) -> Option<&'a TokenConversionRoute> {
    routes
        .iter()
        .filter(|route| {
            route.source_mint == *source_mint
                && route.target_mint == *target_mint
                && route.is_active
        })
        .max_by_key(|route| route.efficiency_score())
}

/// Initialize token conversion for trade
pub fn initialize_token_conversion(
    ctx: Context<InitializeConversion>,
    trade_id: u64,
    conversion_amount: u64,
) -> Result<()> {
    // Validate rent exemption before initialization
    ctx.accounts.validate_rent_exemption()?;

    let conversion_state = &mut ctx.accounts.conversion_state;
    let conversion_route = &ctx.accounts.conversion_route;
    let clock = Clock::get()?;

    // Validate conversion amount
    require!(
        conversion_amount >= ctx.accounts.hub_config.min_conversion_amount,
        ErrorCode::InsufficientConversionAmount
    );

    // Initialize conversion state
    conversion_state.trade_id = trade_id;
    conversion_state.source_mint = conversion_route.source_mint;
    conversion_state.target_mint = conversion_route.target_mint;
    conversion_state.conversion_amount = conversion_amount;
    conversion_state.current_step = 0;
    conversion_state.route_address = conversion_route.key();
    conversion_state.step_start_balance = 0; // Will be set before first step
    conversion_state.total_fees_paid = 0;
    conversion_state.slippage_experienced = 0;
    conversion_state.conversion_status = ConversionStatus::Pending;
    conversion_state.started_at = clock.unix_timestamp;
    conversion_state.authority = ctx.accounts.authority.key();
    conversion_state.bump = ctx.bumps.conversion_state;

    Ok(())
}

// Use common types from profile program
// Types are now imported from localmoney_shared

// Constants
const _DISPUTE_WINDOW_SECONDS: u64 = 24 * 60 * 60; // 24 hours

// Arbitrator account structures

#[account]
pub struct ArbitratorInfo {
    pub arbitrator: Pubkey,
    pub fiat_currency: FiatCurrency,
    pub total_cases: u64,
    pub resolved_cases: u64,
    pub reputation_score: u16, // Basis points (0-10000)
    pub registration_date: i64,
    pub is_active: bool,
    pub bump: u8,
}

impl ArbitratorInfo {
    pub const SPACE: usize = 8 +            // discriminator
        32 +                                // arbitrator
        1 +                                 // fiat_currency
        8 +                                 // total_cases
        8 +                                 // resolved_cases
        2 +                                 // reputation_score
        8 +                                 // registration_date
        1 +                                 // is_active
        1; // bump
}

// COMPREHENSIVE VALIDATION FUNCTIONS

/// Validates trade amount with USD conversion and hub limits
pub fn validate_trade_amount_with_usd_conversion(
    trade_amount: u64,
    token_mint_decimals: u8,
    locked_price: u64,
    fiat_currency: &FiatCurrency,
    hub_config: &hub::HubConfig,
    price_program: &AccountInfo,
) -> Result<()> {
    // Convert trade amount to USD using price oracle
    let usd_equivalent = convert_to_usd_equivalent(
        trade_amount,
        token_mint_decimals,
        locked_price,
        fiat_currency,
        price_program,
    )?;

    // Validate against hub limits
    require!(
        usd_equivalent >= hub_config.trade_limit_min,
        ErrorCode::TradeBelowMinimum
    );

    require!(
        usd_equivalent <= hub_config.trade_limit_max,
        ErrorCode::TradeAboveMaximum
    );

    // Additional overflow protection
    require!(trade_amount > 0, ErrorCode::InvalidTradeAmount);

    // Ensure locked price is reasonable (not zero, not excessively high)
    require!(
        locked_price > 0 && locked_price < u64::MAX / 1000,
        ErrorCode::InvalidLockedPrice
    );

    Ok(())
}

/// Converts trade amount to USD equivalent using price oracle
pub fn convert_to_usd_equivalent(
    trade_amount: u64,
    token_decimals: u8,
    locked_price_in_fiat: u64,
    fiat_currency: &FiatCurrency,
    price_program: &AccountInfo,
) -> Result<u64> {
    // Query USD price for the fiat currency
    let usd_rate = get_fiat_to_usd_rate(fiat_currency, price_program)?;

    // Calculate USD equivalent: (trade_amount * locked_price_in_fiat * usd_rate) / (10^token_decimals * 10^6)
    let amount_in_fiat = (trade_amount as u128)
        .checked_mul(locked_price_in_fiat as u128)
        .ok_or(ErrorCode::ArithmeticError)?;

    let amount_in_usd = amount_in_fiat
        .checked_mul(usd_rate as u128)
        .ok_or(ErrorCode::ArithmeticError)?;

    let divisor = (10u128.pow(token_decimals as u32))
        .checked_mul(1_000_000u128) // 6 decimals for fiat precision
        .ok_or(ErrorCode::ArithmeticError)?;

    let usd_equivalent = amount_in_usd
        .checked_div(divisor)
        .ok_or(ErrorCode::ArithmeticError)?;

    Ok(usd_equivalent as u64)
}

/// Advanced state transition validation with comprehensive checks
pub fn validate_state_transition(
    current_state: &TradeState,
    target_state: &TradeState,
    actor: &Pubkey,
    trade: &Trade,
    current_timestamp: u64,
) -> Result<()> {
    use TradeState::*;

    // Define valid state transitions matrix
    let valid_transition = match (current_state, target_state) {
        // Initial state transitions
        (RequestCreated, RequestAccepted) => trade.seller == *actor,
        (RequestCreated, RequestCanceled) => trade.buyer == *actor || trade.seller == *actor,

        // Funding transitions
        (RequestAccepted, EscrowFunded) => trade.seller == *actor,
        (RequestAccepted, RequestCanceled) => trade.buyer == *actor || trade.seller == *actor,

        // Deposit and release transitions
        (EscrowFunded, FiatDeposited) => trade.buyer == *actor,
        (EscrowFunded, RequestCanceled) => trade.buyer == *actor,
        (FiatDeposited, EscrowReleased) => trade.seller == *actor,

        // Dispute transitions
        (FiatDeposited, EscrowDisputed) => {
            // Check if dispute window is open
            if let Some(dispute_window_at) = trade.dispute_window_at {
                current_timestamp >= dispute_window_at
                    && (trade.buyer == *actor || trade.seller == *actor)
            } else {
                false
            }
        }

        // Settlement transitions (only arbitrator can settle)
        (EscrowDisputed, SettledForMaker) => trade.arbitrator == *actor,
        (EscrowDisputed, SettledForTaker) => trade.arbitrator == *actor,

        // Expiration handling
        (RequestCreated, RequestExpired) => current_timestamp > trade.expires_at,
        (RequestAccepted, RequestExpired) => current_timestamp > trade.expires_at,
        (EscrowFunded, EscrowRefunded) => current_timestamp > trade.expires_at,

        // Invalid transitions
        _ => false,
    };

    require!(valid_transition, ErrorCode::InvalidStateTransition);

    // Additional time-based validations
    validate_timing_constraints(current_state, target_state, trade, current_timestamp)?;

    Ok(())
}

/// Validates timing constraints for state transitions
pub fn validate_timing_constraints(
    current_state: &TradeState,
    target_state: &TradeState,
    trade: &Trade,
    current_timestamp: u64,
) -> Result<()> {
    use TradeState::*;

    match (current_state, target_state) {
        // Ensure trade hasn't expired for active transitions
        (RequestCreated | RequestAccepted, EscrowFunded | FiatDeposited) => {
            require!(
                current_timestamp <= trade.expires_at,
                ErrorCode::TradeExpired
            );
        }

        // Validate dispute timing
        (FiatDeposited, EscrowDisputed) => {
            if let Some(dispute_window) = trade.dispute_window_at {
                require!(
                    current_timestamp >= dispute_window,
                    ErrorCode::PrematureDisputeRequest
                );
            } else {
                return Err(ErrorCode::DisputeWindowNotOpen.into());
            }
        }

        // Ensure refunds only happen after expiration
        (EscrowFunded, EscrowRefunded) => {
            require!(
                current_timestamp > trade.expires_at,
                ErrorCode::RefundNotAllowed
            );
        }

        _ => {}
    }

    Ok(())
}

/// Enhanced ownership and authorization validation
pub fn validate_comprehensive_authorization(
    actor: &Pubkey,
    trade: &Trade,
    required_role: AuthorizationRole,
) -> Result<()> {
    let is_authorized = match required_role {
        AuthorizationRole::Buyer => trade.buyer == *actor,
        AuthorizationRole::Seller => trade.seller == *actor,
        AuthorizationRole::Arbitrator => trade.arbitrator == *actor,
        AuthorizationRole::BuyerOrSeller => trade.buyer == *actor || trade.seller == *actor,
        AuthorizationRole::Any => true, // For operations like checking expired trades
        AuthorizationRole::Admin => {
            // This would require passing hub_config to check admin
            // For now, we'll handle admin checks separately
            false
        }
    };

    require!(is_authorized, ErrorCode::Unauthorized);

    // Additional security checks
    validate_account_security(actor, trade)?;

    Ok(())
}

/// Validates account security and prevents common attack vectors
pub fn validate_account_security(actor: &Pubkey, trade: &Trade) -> Result<()> {
    // Prevent zero address attacks
    require!(*actor != Pubkey::default(), ErrorCode::InvalidAccount);

    // Ensure buyer and seller are different
    require!(trade.buyer != trade.seller, ErrorCode::SelfTradeNotAllowed);

    // Ensure arbitrator is different from both parties
    require!(
        trade.arbitrator != trade.buyer && trade.arbitrator != trade.seller,
        ErrorCode::InvalidArbitratorAssignment
    );

    // Check for suspicious patterns
    if is_suspicious_pattern(actor) {
        emit!(SecurityAlertEvent {
            alert_type: "suspicious_account".to_string(),
            severity: 3,
            actor: *actor,
            details: format!("Suspicious activity detected for trade {}", trade.id),
            timestamp: Clock::get()?.unix_timestamp,
            alert_index: "suspicious_account".to_string(),
        });
    }

    Ok(())
}

fn is_suspicious_pattern(account: &Pubkey) -> bool {
    // Check for known attack patterns
    let account_bytes = account.to_bytes();
    
    // Pattern 1: All zeros except last few bytes (common in generated attacks)
    let zero_count = account_bytes.iter().filter(|&&b| b == 0).count();
    if zero_count > 28 { return true; }
    
    // Pattern 2: Sequential bytes (could indicate programmatic generation)
    let mut sequential = true;
    for i in 1..account_bytes.len() {
        if account_bytes[i] != account_bytes[i-1].wrapping_add(1) {
            sequential = false;
            break;
        }
    }
    if sequential { return true; }
    
    false
}

/// Validates CPI calls for cross-program security
pub fn validate_cpi_call_security(
    program_id: &Pubkey,
    expected_program: &Pubkey,
    instruction_data: &[u8],
) -> Result<()> {
    // Ensure we're calling the expected program
    require!(
        program_id == expected_program,
        ErrorCode::UnauthorizedCpiCall
    );

    // Validate instruction data isn't empty (prevents certain attack vectors)
    require!(!instruction_data.is_empty(), ErrorCode::InvalidCpiData);

    // Additional CPI security validations could go here
    // Such as checking specific instruction discriminators

    Ok(())
}

/// Comprehensive fee calculation validation
pub fn validate_fee_calculation(amount: u64, fee_info: &FeeInfo) -> Result<()> {
    // Ensure no overflow in fee calculations
    let total_fees = fee_info.total_fees();
    require!(total_fees <= amount, ErrorCode::ExcessiveFees);

    // Ensure individual fee components are reasonable
    require!(
        fee_info.burn_amount <= amount / 10, // Max 10% burn
        ErrorCode::ExcessiveBurnFee
    );

    require!(
        fee_info.chain_amount <= amount / 10, // Max 10% chain fee
        ErrorCode::ExcessiveChainFee
    );

    require!(
        fee_info.warchest_amount <= amount / 10, // Max 10% warchest fee
        ErrorCode::ExcessiveWarchestFee
    );

    Ok(())
}

/// Automatic refund mechanism with comprehensive validation
pub fn execute_automatic_refund(
    trade: &mut Trade,
    current_timestamp: u64,
    _actor: &Pubkey,
) -> Result<()> {
    // Validate that refund conditions are met
    require!(
        current_timestamp > trade.expires_at,
        ErrorCode::RefundNotAllowed
    );

    require!(
        trade.state == TradeState::EscrowFunded,
        ErrorCode::InvalidTradeState
    );

    // Anyone can trigger an automatic refund for expired funded trades
    // This is a public service that helps prevent locked funds

    // Additional validation: ensure trade has been expired for minimum duration
    let minimum_expiry_buffer = 3600; // 1 hour buffer
    require!(
        current_timestamp > trade.expires_at.safe_add(minimum_expiry_buffer)?,
        ErrorCode::RefundTooEarly
    );

    Ok(())
}

/// Gets fiat to USD conversion rate from price oracle
pub fn get_fiat_to_usd_rate(
    fiat_currency: &FiatCurrency,
    _price_program: &AccountInfo,
) -> Result<u64> {
    // In a real implementation, this would query the price oracle
    // For now, we'll use approximate rates (this should be replaced with actual oracle calls)
    let rate = match fiat_currency {
        FiatCurrency::Usd => 1_000_000, // 1:1 ratio, 6 decimal places
        FiatCurrency::Eur => 1_100_000, // ~1.1 USD per EUR
        FiatCurrency::Gbp => 1_250_000, // ~1.25 USD per GBP
        FiatCurrency::Cad => 750_000,   // ~0.75 USD per CAD
        FiatCurrency::Aud => 670_000,   // ~0.67 USD per AUD
        FiatCurrency::Jpy => 7_000,     // ~0.007 USD per JPY
        FiatCurrency::Brl => 200_000,   // ~0.2 USD per BRL
        FiatCurrency::Mxn => 60_000,    // ~0.06 USD per MXN
        FiatCurrency::Ars => 1_200,     // ~0.0012 USD per ARS
        FiatCurrency::Clp => 1_100,     // ~0.0011 USD per CLP
        FiatCurrency::Cop => 250,       // ~0.00025 USD per COP
        FiatCurrency::Ngn => 1_300,     // ~0.0013 USD per NGN
        FiatCurrency::Thb => 28_000,    // ~0.028 USD per THB
        FiatCurrency::Ves => 30,        // ~0.00003 USD per VES
    };

    Ok(rate)
}

/// Authorization roles for comprehensive access control
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum AuthorizationRole {
    Buyer,
    Seller,
    Arbitrator,
    BuyerOrSeller,
    Admin,
    Any,
}

// Helper functions
pub fn fiat_currency_to_string(currency: &FiatCurrency) -> &'static str {
    match currency {
        FiatCurrency::Usd => "USD",
        FiatCurrency::Eur => "EUR",
        FiatCurrency::Gbp => "GBP",
        FiatCurrency::Cad => "CAD",
        FiatCurrency::Aud => "AUD",
        FiatCurrency::Jpy => "JPY",
        FiatCurrency::Brl => "BRL",
        FiatCurrency::Mxn => "MXN",
        FiatCurrency::Ars => "ARS",
        FiatCurrency::Clp => "CLP",
        FiatCurrency::Cop => "COP",
        FiatCurrency::Ngn => "NGN",
        FiatCurrency::Thb => "THB",
        FiatCurrency::Ves => "VES",
    }
}

// CosmWasm-compatible fee calculation for arbitration settlement
pub fn calculate_arbitration_settlement_fees(
    trade_amount: u64,
    hub_config: &hub::HubConfig,
    offer: &offer::Offer,
    trade: &Trade,
    _winner: &Pubkey,
) -> Result<ArbitrationSettlementFees> {
    // Calculate arbitration fee (e.g., 2% as basis points)
    // Assuming hub_config has arbitration_fee_rate field - using fee_rate as approximation
    let arbitration_fee_basis_points = hub_config.fee_rate; // e.g., 200 = 2%
    let arbitrator_fee =
        (trade_amount as u128 * arbitration_fee_basis_points as u128 / 10000) as u64;

    // Start with full trade amount minus arbitrator fee
    let mut winner_amount = trade_amount - arbitrator_fee;

    // Protocol fees only deducted if buyer is the maker (matching CosmWasm logic)
    let protocol_fee = if trade.buyer == offer.owner {
        // Buyer is maker - deduct protocol fees
        // Calculate total protocol fees similar to existing calculate_fees function
        let fee_info = calculate_fees(trade_amount)?;
        let total_protocol_fees = fee_info.total_fees();

        winner_amount = winner_amount - total_protocol_fees;

        total_protocol_fees
    } else {
        // Buyer is taker - no additional protocol fees
        0
    };

    Ok(ArbitrationSettlementFees {
        winner_amount,
        arbitrator_fee,
        protocol_fee,
        conversion_fee: 0,
        gas_compensation: 0,
        penalty_fee: 0,
    })
}

// CosmWasm-compatible arbitrator selection algorithm
pub fn select_arbitrator_from_pool(
    arbitrator_pool: &ArbitratorPool,
    random_index: usize,
) -> Result<Pubkey> {
    require!(
        !arbitrator_pool.total_arbitrators == 0,
        ErrorCode::NoArbitratorsAvailable
    );

    // Take up to 10 arbitrators from pool (gas efficiency like CosmWasm)
    // TODO: Get arbitrators from paginated pages
    let available_arbitrators: Vec<Pubkey> = vec![];  // Placeholder
    let arbitrator_count = arbitrator_pool.total_arbitrators as usize;

    // Secure mapping: RandomValue * (MaxMappedRange + 1) / (MaxRandomRange + 1)
    // Matches CosmWasm algorithm exactly
    let selected_index = random_index * arbitrator_count / (99 + 1);

    Ok(available_arbitrators[selected_index])
}

// Weighted arbitrator selection working with paginated pool structure
fn select_weighted_arbitrator(
    randomness: &[u8; 32],
    pool: &ArbitratorPool,
    arbitrator_pages: &[AccountInfo],
) -> Result<Pubkey> {
    require!(pool.total_arbitrators > 0, ErrorCode::NoArbitratorsAvailable);
    
    // For simplified implementation, use basic random selection from available arbitrators
    // In a full implementation, this would iterate through all pages and calculate weights
    
    // Get arbitrators from the first page for demonstration
    if arbitrator_pages.is_empty() {
        return Err(ErrorCode::NoArbitratorsAvailable.into());
    }
    
    // Parse the first arbitrator page
    let first_page_data = &arbitrator_pages[0].try_borrow_data()?;
    
    // For now, implement simplified selection
    // In practice, you would:
    // 1. Iterate through all ArbitratorPage accounts
    // 2. Load each arbitrator's ArbitratorInfo
    // 3. Calculate weights for active arbitrators
    // 4. Use weighted random selection
    
    // Simplified random selection using first available arbitrator from pool
    let random_value = u64::from_le_bytes(randomness[0..8].try_into().unwrap());
    let arbitrator_index = (random_value % pool.total_arbitrators as u64) as usize;
    
    // For demonstration, return a placeholder arbitrator
    // In a real implementation, this would properly parse the page data
    // and return the selected arbitrator
    
    // Use the pool's authority as a placeholder (this should be replaced with proper logic)
    Ok(pool.authority)
}

/// DYNAMIC FEE CALCULATION: Advanced fee calculation with multiple parameters
/// Matches CosmWasm implementation complexity with Solana optimizations
pub fn calculate_dynamic_fees(
    amount: u64,
    token_mint: &Pubkey,
    hub_config: &hub::HubConfig,
    trade: Option<&Trade>,
    offer: Option<&offer::Offer>,
    fee_calculation_method: FeeCalculationMethod,
) -> Result<FeeInfo> {
    // Determine if token conversion is required
    let requires_conversion = *token_mint != hub_config.local_token_mint;

    // Calculate base fees using the specified method
    let (burn_amount, chain_amount, warchest_amount, conversion_fee, slippage_reserve) =
        match fee_calculation_method {
            FeeCalculationMethod::Percentage => {
                calculate_percentage_fees(amount, hub_config, requires_conversion)?
            }
            FeeCalculationMethod::Dynamic => {
                calculate_adaptive_fees(amount, hub_config, trade, offer, requires_conversion)?
            }
            FeeCalculationMethod::Tiered => {
                calculate_tiered_fees(amount, hub_config, requires_conversion)?
            }
            FeeCalculationMethod::MakerTaker => {
                calculate_maker_taker_fees(amount, hub_config, trade, offer, requires_conversion)?
            }
            FeeCalculationMethod::TokenSpecific => {
                calculate_token_specific_fees(amount, token_mint, hub_config, requires_conversion)?
            }
        };

    // Create and validate fee info
    FeeInfo::new(
        amount,
        burn_amount,
        chain_amount,
        warchest_amount,
        conversion_fee,
        slippage_reserve,
        requires_conversion,
        fee_calculation_method,
    )
}

/// PERCENTAGE FEES: Standard percentage-based fee calculation
fn calculate_percentage_fees(
    amount: u64,
    hub_config: &hub::HubConfig,
    requires_conversion: bool,
) -> Result<(u64, u64, u64, u64, u64)> {
    // Use enhanced hub config fee percentages
    let burn_amount = (amount as u128 * hub_config.burn_fee_pct as u128 / 10000) as u64;
    let chain_amount = (amount as u128 * hub_config.chain_fee_pct as u128 / 10000) as u64;
    let warchest_amount = (amount as u128 * hub_config.warchest_fee_pct as u128 / 10000) as u64;

    // Additional fees for token conversion
    let (conversion_fee, slippage_reserve) = if requires_conversion {
        let conv_fee = (amount as u128 * hub_config.conversion_fee_pct as u128 / 10000) as u64;
        let slippage = (amount as u128 * hub_config.max_slippage_bps as u128 / 10000) as u64;
        (conv_fee, slippage)
    } else {
        (0, 0)
    };

    Ok((
        burn_amount,
        chain_amount,
        warchest_amount,
        conversion_fee,
        slippage_reserve,
    ))
}

/// DYNAMIC FEES: Adaptive fees based on trade and market conditions
fn calculate_adaptive_fees(
    amount: u64,
    hub_config: &hub::HubConfig,
    trade: Option<&Trade>,
    offer: Option<&offer::Offer>,
    requires_conversion: bool,
) -> Result<(u64, u64, u64, u64, u64)> {
    // Start with base percentage fees
    let (mut burn_amount, mut chain_amount, mut warchest_amount, conversion_fee, slippage_reserve) =
        calculate_percentage_fees(amount, hub_config, requires_conversion)?;

    // Dynamic adjustments based on trade parameters
    if let Some(trade_data) = trade {
        // Time-based fee adjustment (lower fees for longer-duration trades)
        let current_time = Clock::get()?.unix_timestamp as u64;
        let trade_age = current_time.saturating_sub(trade_data.created_at);
        let age_factor = if trade_age > 86400 { 90 } else { 100 }; // 10% discount for trades older than 1 day

        burn_amount = burn_amount * age_factor / 100;
        chain_amount = chain_amount * age_factor / 100;
        warchest_amount = warchest_amount * age_factor / 100;

        // Volume-based adjustments (lower fees for larger amounts)
        let volume_factor = if amount > 1_000_000_000 {
            90
        } else if amount > 100_000_000 {
            95
        } else {
            100
        };

        burn_amount = burn_amount * volume_factor / 100;
        chain_amount = chain_amount * volume_factor / 100;
        warchest_amount = warchest_amount * volume_factor / 100;
    }

    // Offer-type specific adjustments
    if let Some(_offer_data) = offer {
        // Adjust fees based on offer characteristics
        // Market makers (frequent traders) get slight fee reductions
        let maker_factor = 95; // 5% discount for offer creators

        burn_amount = burn_amount * maker_factor / 100;
        chain_amount = chain_amount * maker_factor / 100;
        warchest_amount = warchest_amount * maker_factor / 100;
    }

    Ok((
        burn_amount,
        chain_amount,
        warchest_amount,
        conversion_fee,
        slippage_reserve,
    ))
}

/// TIERED FEES: Amount-based tiered fee structure
fn calculate_tiered_fees(
    amount: u64,
    hub_config: &hub::HubConfig,
    requires_conversion: bool,
) -> Result<(u64, u64, u64, u64, u64)> {
    // Define fee tiers (in basis points)
    let (burn_bps, chain_bps, warchest_bps) = match amount {
        // Tier 1: 0-1M tokens - Standard rates
        0..=1_000_000_000 => (
            hub_config.burn_fee_pct,
            hub_config.chain_fee_pct,
            hub_config.warchest_fee_pct,
        ),
        // Tier 2: 1M-10M tokens - 10% discount
        1_000_000_001..=10_000_000_000 => (
            hub_config.burn_fee_pct * 90 / 100,
            hub_config.chain_fee_pct * 90 / 100,
            hub_config.warchest_fee_pct * 90 / 100,
        ),
        // Tier 3: 10M+ tokens - 20% discount
        _ => (
            hub_config.burn_fee_pct * 80 / 100,
            hub_config.chain_fee_pct * 80 / 100,
            hub_config.warchest_fee_pct * 80 / 100,
        ),
    };

    let burn_amount = (amount as u128 * burn_bps as u128 / 10000) as u64;
    let chain_amount = (amount as u128 * chain_bps as u128 / 10000) as u64;
    let warchest_amount = (amount as u128 * warchest_bps as u128 / 10000) as u64;

    // Conversion fees with tiered discounts
    let (conversion_fee, slippage_reserve) = if requires_conversion {
        let conv_bps = match amount {
            0..=1_000_000_000 => hub_config.conversion_fee_pct,
            1_000_000_001..=10_000_000_000 => hub_config.conversion_fee_pct * 90 / 100,
            _ => hub_config.conversion_fee_pct * 80 / 100,
        };

        let conv_fee = (amount as u128 * conv_bps as u128 / 10000) as u64;
        let slippage = (amount as u128 * hub_config.max_slippage_bps as u128 / 10000) as u64;
        (conv_fee, slippage)
    } else {
        (0, 0)
    };

    Ok((
        burn_amount,
        chain_amount,
        warchest_amount,
        conversion_fee,
        slippage_reserve,
    ))
}

/// MAKER-TAKER FEES: Differentiated fees based on market role
fn calculate_maker_taker_fees(
    amount: u64,
    hub_config: &hub::HubConfig,
    trade: Option<&Trade>,
    offer: Option<&offer::Offer>,
    requires_conversion: bool,
) -> Result<(u64, u64, u64, u64, u64)> {
    // Determine if this is maker or taker
    let is_maker = if let (Some(trade_data), Some(offer_data)) = (trade, offer) {
        // Offer owner is the maker, trade creator is the taker
        trade_data.buyer == offer_data.owner || trade_data.seller == offer_data.owner
    } else {
        false // Default to taker fees
    };

    // Apply maker/taker fee structure
    let fee_multiplier = if is_maker { 90 } else { 100 }; // 10% discount for makers

    let burn_amount = (amount as u128 * hub_config.burn_fee_pct as u128 * fee_multiplier as u128
        / 1_000_000) as u64;
    let chain_amount = (amount as u128 * hub_config.chain_fee_pct as u128 * fee_multiplier as u128
        / 1_000_000) as u64;
    let warchest_amount =
        (amount as u128 * hub_config.warchest_fee_pct as u128 * fee_multiplier as u128 / 1_000_000)
            as u64;

    // Conversion fees
    let (conversion_fee, slippage_reserve) = if requires_conversion {
        let conv_fee =
            (amount as u128 * hub_config.conversion_fee_pct as u128 * fee_multiplier as u128
                / 1_000_000) as u64;
        let slippage = (amount as u128 * hub_config.max_slippage_bps as u128 / 10000) as u64;
        (conv_fee, slippage)
    } else {
        (0, 0)
    };

    Ok((
        burn_amount,
        chain_amount,
        warchest_amount,
        conversion_fee,
        slippage_reserve,
    ))
}

/// TOKEN-SPECIFIC FEES: Custom fees based on token characteristics
fn calculate_token_specific_fees(
    amount: u64,
    token_mint: &Pubkey,
    hub_config: &hub::HubConfig,
    requires_conversion: bool,
) -> Result<(u64, u64, u64, u64, u64)> {
    // Start with base fees
    let (
        mut burn_amount,
        mut chain_amount,
        mut warchest_amount,
        mut conversion_fee,
        mut slippage_reserve,
    ) = calculate_percentage_fees(amount, hub_config, requires_conversion)?;

    // LOCAL token gets special treatment
    if *token_mint == hub_config.local_token_mint {
        // Lower fees for native LOCAL token trades
        let local_discount = 80; // 20% discount
        burn_amount = burn_amount * local_discount / 100;
        chain_amount = chain_amount * local_discount / 100;
        warchest_amount = warchest_amount * local_discount / 100;
        conversion_fee = 0; // No conversion needed
        slippage_reserve = 0;
    } else {
        // Higher conversion fees for exotic tokens (simplified logic)
        // In production, this would check against a token registry
        conversion_fee = conversion_fee * 120 / 100; // 20% higher conversion fees
        slippage_reserve = slippage_reserve * 130 / 100; // 30% higher slippage protection
    }

    Ok((
        burn_amount,
        chain_amount,
        warchest_amount,
        conversion_fee,
        slippage_reserve,
    ))
}

/// LEGACY COMPATIBILITY: Simple fee calculation for backward compatibility
pub fn calculate_fees(amount: u64) -> Result<FeeInfo> {
    // Create a default hub config for legacy support
    let default_hub_config = hub::HubConfig {
        authority: Pubkey::default(),
        profile_program: Pubkey::default(),
        offer_program: Pubkey::default(),
        trade_program: Pubkey::default(),
        price_program: Pubkey::default(),
        treasury: Pubkey::default(),
        local_token_mint: Pubkey::default(),
        jupiter_program: Pubkey::default(),
        chain_fee_collector: Pubkey::default(),
        warchest_address: Pubkey::default(),
        burn_fee_pct: 50,       // 0.5%
        chain_fee_pct: 50,      // 0.5%
        warchest_fee_pct: 50,   // 0.5%
        conversion_fee_pct: 25, // 0.25%
        max_slippage_bps: 100,  // 1%
        min_conversion_amount: 1000,
        max_conversion_routes: 3,
        fee_rate: 150, // Legacy field
        burn_rate: 50,
        warchest_rate: 50,
        trade_limit_min: 1000,
        trade_limit_max: 1000000,
        trade_expiration_timer: 86400,
        trade_dispute_timer: 3600,
        arbitration_fee_rate: 200,
        // Program version tracking fields
        profile_program_version: 1,
        offer_program_version: 1,
        trade_program_version: 1,
        price_program_version: 1,
        last_upgrade_timestamp: 0,
        upgrade_authority: Pubkey::default(),
        // Circuit breaker fields
        emergency_council: [Pubkey::default(); 5],
        guardian_count: 0,
        required_signatures: 2,
        global_pause: false,
        pause_new_trades: false,
        pause_deposits: false,
        pause_withdrawals: false,
        pause_new_offers: false,
        pause_timestamp: 0,
        auto_resume_after: 0,
        pause_reason: [0u8; 32],
        pause_count: 0,
        last_pause_by: Pubkey::default(),
        bump: 0,
    };

    calculate_dynamic_fees(
        amount,
        &Pubkey::default(), // Default token (treated as non-LOCAL)
        &default_hub_config,
        None,
        None,
        FeeCalculationMethod::Percentage,
    )
}

/// LOCAL TOKEN BURN MECHANISM: Comprehensive burn system with automatic conversion
/// Matches CosmWasm pattern for LOCAL token burning and token conversion

/// Execute LOCAL token burn with automatic conversion for non-LOCAL tokens
pub fn execute_local_token_burn(ctx: Context<ExecuteTokenBurn>, burn_amount: u64) -> Result<()> {
    let hub_config = &ctx.accounts.hub_config;
    let token_mint = &ctx.accounts.token_mint;

    // Check if token is LOCAL or needs conversion
    if token_mint.key() == hub_config.local_token_mint {
        // Direct burn for LOCAL tokens
        burn_local_tokens(ctx, burn_amount)?;
    } else {
        // Convert to LOCAL then burn
        convert_and_burn_tokens(ctx, burn_amount)?;
    }

    Ok(())
}

/// Direct burn of LOCAL tokens using SPL token program
fn burn_local_tokens(ctx: Context<ExecuteTokenBurn>, burn_amount: u64) -> Result<()> {
    use anchor_spl::token_interface::Burn;

    // Validate burn amount
    require!(burn_amount > 0, ErrorCode::InvalidParameter);

    // Create burn instruction
    let cpi_accounts = Burn {
        mint: ctx.accounts.token_mint.to_account_info(),
        from: ctx.accounts.source_token_account.to_account_info(),
        authority: ctx.accounts.authority.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

    // Execute burn using anchor helper
    anchor_spl::token_interface::burn(cpi_ctx, burn_amount)?;

    // Update burn statistics
    // Note: burn_statistics update would require mutable context
    // This functionality can be added when the calling function has mutable access

    Ok(())
}

/// Convert non-LOCAL token to LOCAL and burn the result
fn convert_and_burn_tokens(ctx: Context<ExecuteTokenBurn>, burn_amount: u64) -> Result<()> {
    let hub_config = &ctx.accounts.hub_config;

    // Validate minimum conversion amount
    require!(
        burn_amount >= hub_config.min_conversion_amount,
        ErrorCode::InsufficientConversionAmount
    );

    // Step 1: Convert non-LOCAL token to LOCAL via DEX
    let converted_amount = execute_token_conversion_for_burn(&ctx, burn_amount)?;

    // Step 2: Burn the converted LOCAL tokens
    burn_converted_local_tokens(&ctx, converted_amount)?;

    Ok(())
}

/// Execute token conversion through DEX protocols
fn execute_token_conversion_for_burn(ctx: &Context<ExecuteTokenBurn>, amount: u64) -> Result<u64> {
    let hub_config = &ctx.accounts.hub_config;
    let source_mint = &ctx.accounts.token_mint;
    let target_mint = &hub_config.local_token_mint;

    // Get conversion route (in production, this would query stored routes)
    let conversion_route = get_conversion_route_for_burn(&source_mint.key(), target_mint, ctx)?;

    // Execute conversion through Jupiter or other DEX
    let converted_amount = match conversion_route.route_steps.len() {
        1 => execute_single_step_conversion(ctx, amount, &conversion_route.route_steps[0])?,
        2..=5 => execute_multi_step_conversion(ctx, amount, &conversion_route.route_steps)?,
        _ => return Err(ErrorCode::ConversionRouteTooComplex.into()),
    };

    // Validate slippage
    let expected_min_output =
        calculate_min_output_with_slippage(amount, hub_config.max_slippage_bps)?;

    require!(
        converted_amount >= expected_min_output,
        ErrorCode::SlippageExceeded
    );

    Ok(converted_amount)
}

/// Execute single-step token conversion
fn execute_single_step_conversion(
    ctx: &Context<ExecuteTokenBurn>,
    amount: u64,
    conversion_step: &ConversionStep,
) -> Result<u64> {
    // Query initial balance of target token
    let initial_balance =
        get_token_account_balance(&ctx.accounts.temp_local_token_account.to_account_info())?;

    // Execute swap through Jupiter CPI
    execute_jupiter_swap_cpi(ctx, amount, conversion_step)?;

    // Query final balance to determine converted amount
    let final_balance =
        get_token_account_balance(&ctx.accounts.temp_local_token_account.to_account_info())?;

    let converted_amount = final_balance.saturating_sub(initial_balance);

    require!(converted_amount > 0, ErrorCode::TokenConversionFailed);

    Ok(converted_amount)
}

/// Execute multi-step token conversion
fn execute_multi_step_conversion(
    ctx: &Context<ExecuteTokenBurn>,
    initial_amount: u64,
    conversion_steps: &[ConversionStep],
) -> Result<u64> {
    let mut current_amount = initial_amount;

    for (step_index, step) in conversion_steps.iter().enumerate() {
        // For multi-step conversions, we need intermediate token accounts
        // This would require more complex account management in production
        current_amount = execute_single_step_conversion(ctx, current_amount, step)?;

        // Validate intermediate amounts
        require!(current_amount > 0, ErrorCode::TokenConversionFailed);

        // Apply step-by-step slippage checks
        if step_index > 0 {
            let expected_min = calculate_step_min_output(current_amount, step.max_slippage_bps)?;

            require!(current_amount >= expected_min, ErrorCode::SlippageExceeded);
        }
    }

    Ok(current_amount)
}

/// Execute Jupiter DEX swap via CPI
fn execute_jupiter_swap_cpi(
    ctx: &Context<ExecuteTokenBurn>,
    amount: u64,
    conversion_step: &ConversionStep,
) -> Result<()> {
    // This is a simplified Jupiter CPI call
    // In production, this would use the full Jupiter CPI interface

    let jupiter_program = &ctx.accounts.jupiter_program;
    let _pool_address = &conversion_step.pool_address;

    // Validate Jupiter program
    require!(
        jupiter_program.key() == ctx.accounts.hub_config.jupiter_program,
        ErrorCode::InvalidDexProgram
    );

    // Create Jupiter swap instruction data
    let swap_instruction_data = create_jupiter_swap_instruction(
        amount,
        conversion_step.max_slippage_bps,
        &conversion_step.input_mint,
        &conversion_step.output_mint,
    )?;

    // Execute CPI call to Jupiter
    let cpi_accounts = vec![
        ctx.accounts.source_token_account.to_account_info(),
        ctx.accounts.temp_local_token_account.to_account_info(),
        ctx.accounts.authority.to_account_info(),
        ctx.accounts.token_mint.to_account_info(),
        jupiter_program.to_account_info(),
    ];

    // In production, this would be a proper CPI call using Jupiter's interface
    solana_program::program::invoke(
        &solana_program::instruction::Instruction {
            program_id: jupiter_program.key(),
            accounts: cpi_accounts
                .iter()
                .map(|acc| solana_program::instruction::AccountMeta {
                    pubkey: acc.key(),
                    is_signer: acc.is_signer,
                    is_writable: acc.is_writable,
                })
                .collect(),
            data: swap_instruction_data,
        },
        &cpi_accounts,
    )?;

    Ok(())
}

/// Burn converted LOCAL tokens
fn burn_converted_local_tokens(ctx: &Context<ExecuteTokenBurn>, amount: u64) -> Result<()> {
    use anchor_spl::token_interface::Burn;

    // Create burn instruction for converted LOCAL tokens
    let cpi_accounts = Burn {
        mint: ctx.accounts.local_token_mint.to_account_info(),
        from: ctx.accounts.temp_local_token_account.to_account_info(),
        authority: ctx.accounts.authority.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

    // Execute burn
    anchor_spl::token_interface::burn(cpi_ctx, amount)?;

    // Update conversion burn statistics
    // Note: burn_statistics update would require mutable context
    // This functionality can be added when the calling function has mutable access

    Ok(())
}

/// HELPER FUNCTIONS for burn mechanism

/// Get conversion route for burn operation
fn get_conversion_route_for_burn(
    source_mint: &Pubkey,
    target_mint: &Pubkey,
    _ctx: &Context<ExecuteTokenBurn>,
) -> Result<TokenConversionRoute> {
    // In production, this would query stored conversion routes
    // For now, create a default single-step route
    let default_step = ConversionStep {
        dex_program: Pubkey::default(), // Would be Jupiter program ID
        input_mint: *source_mint,
        output_mint: *target_mint,
        pool_address: Pubkey::default(), // Would be actual pool address
        estimated_fee: 1000,             // 0.1% estimated fee
        max_slippage_bps: 100,           // 1% max slippage
    };

    Ok(TokenConversionRoute {
        source_mint: *source_mint,
        target_mint: *target_mint,
        route_steps: vec![default_step],
        total_estimated_fee: 1000,
        max_total_slippage_bps: 100,
        route_priority: 0,
        is_active: true,
        created_at: Clock::get()?.unix_timestamp,
        last_updated: Clock::get()?.unix_timestamp,
        success_count: 0,
        failure_count: 0,
        authority: Pubkey::default(),
        bump: 0,
    })
}

/// Calculate minimum output amount considering slippage
fn calculate_min_output_with_slippage(input_amount: u64, max_slippage_bps: u16) -> Result<u64> {
    let slippage_factor = 10000u64.saturating_sub(max_slippage_bps as u64);
    let min_output = (input_amount as u128 * slippage_factor as u128 / 10000u128) as u64;
    Ok(min_output)
}

/// Calculate minimum output for individual step
fn calculate_step_min_output(input_amount: u64, step_slippage_bps: u16) -> Result<u64> {
    calculate_min_output_with_slippage(input_amount, step_slippage_bps)
}

/// Get token account balance
fn get_token_account_balance(account_info: &AccountInfo) -> Result<u64> {
    let account_data = account_info.try_borrow_data()?;

    // SPL Token account balance is at offset 64 (8 bytes)
    if account_data.len() < 72 {
        return Err(ErrorCode::InvalidAccount.into());
    }

    let balance_bytes = &account_data[64..72];
    let balance = u64::from_le_bytes(
        balance_bytes
            .try_into()
            .map_err(|_| ErrorCode::InvalidAccount)?,
    );

    Ok(balance)
}

/// Create Jupiter swap instruction data (simplified)
fn create_jupiter_swap_instruction(
    amount: u64,
    slippage_bps: u16,
    input_mint: &Pubkey,
    output_mint: &Pubkey,
) -> Result<Vec<u8>> {
    // This is a simplified instruction format
    // In production, this would use Jupiter's actual instruction format
    let mut instruction_data = Vec::new();

    // Add swap discriminator (8 bytes)
    instruction_data.extend_from_slice(&[1, 2, 3, 4, 5, 6, 7, 8]);

    // Add amount (8 bytes)
    instruction_data.extend_from_slice(&amount.to_le_bytes());

    // Add slippage (2 bytes)
    instruction_data.extend_from_slice(&slippage_bps.to_le_bytes());

    // Add input mint (32 bytes)
    instruction_data.extend_from_slice(input_mint.as_ref());

    // Add output mint (32 bytes)
    instruction_data.extend_from_slice(output_mint.as_ref());

    Ok(instruction_data)
}

/// BURN STATISTICS: Track burn operations for analytics
#[account]
pub struct BurnStatistics {
    pub total_burned: u64,                   // Total LOCAL tokens burned directly
    pub total_converted_burned: u64,         // Total LOCAL tokens burned after conversion
    pub burn_count: u64,                     // Number of direct burns
    pub conversion_burn_count: u64,          // Number of conversion burns
    pub last_burn_timestamp: i64,            // Last direct burn timestamp
    pub last_conversion_burn_timestamp: i64, // Last conversion burn timestamp
    pub authority: Pubkey,                   // Statistics authority
    pub bump: u8,
}

impl BurnStatistics {
    pub const SPACE: usize = 8 +              // discriminator
        8 +                                   // total_burned
        8 +                                   // total_converted_burned
        8 +                                   // burn_count
        8 +                                   // conversion_burn_count
        8 +                                   // last_burn_timestamp
        8 +                                   // last_conversion_burn_timestamp
        32 +                                  // authority
        1; // bump
}

/// ACCOUNT CONTEXT: Token burn operations
#[derive(Accounts)]
pub struct ExecuteTokenBurn<'info> {
    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = authority,
        associated_token::token_program = token_program,
    )]
    pub source_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(
        init_if_needed,
        payer = authority,
        associated_token::mint = local_token_mint,
        associated_token::authority = authority,
        associated_token::token_program = token_program,
    )]
    pub temp_local_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(mut)]
    pub token_mint: InterfaceAccount<'info, Mint>,

    #[account(
        mut,
        seeds = [b"mint".as_ref(), b"local".as_ref()],
        bump,
        mint::token_program = token_program
    )]
    pub local_token_mint: InterfaceAccount<'info, Mint>,

    #[account(
        seeds = [b"hub".as_ref(), b"config".as_ref()],
        bump
    )]
    pub hub_config: Account<'info, hub::HubConfig>,

    #[account(
        mut,
        seeds = [b"burn_statistics".as_ref()],
        bump
    )]
    pub burn_statistics: Option<Account<'info, BurnStatistics>>,

    /// CHECK: Jupiter program for DEX operations
    pub jupiter_program: UncheckedAccount<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub token_program: Interface<'info, TokenInterface>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}

/// MULTI-DESTINATION FEE DISTRIBUTION: Core fee distribution logic
/// Matches CosmWasm implementation pattern for comprehensive fee handling

/// Execute multi-destination fee distribution with LOCAL token burn
fn execute_multi_destination_fee_distribution(
    ctx: &Context<ReleaseEscrow>,
    fee_info: &FeeInfo,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let _hub_config = &ctx.accounts.hub_config;
    let _token_mint = &ctx.accounts.token_mint;

    // BURN FEE DISTRIBUTION: Handle LOCAL token burn or conversion + burn
    if fee_info.burn_amount > 0 {
        execute_burn_fee_distribution(ctx, fee_info.burn_amount, signer_seeds)?;
    }

    // CHAIN FEE DISTRIBUTION: Transfer to chain fee collector
    if fee_info.chain_amount > 0 {
        execute_chain_fee_distribution(ctx, fee_info.chain_amount, signer_seeds)?;
    }

    // WARCHEST FEE DISTRIBUTION: Transfer to warchest address
    if fee_info.warchest_amount > 0 {
        execute_warchest_fee_distribution(ctx, fee_info.warchest_amount, signer_seeds)?;
    }

    // CONVERSION FEE HANDLING: Handle conversion fees if applicable
    if fee_info.conversion_fee > 0 {
        execute_conversion_fee_distribution(ctx, fee_info.conversion_fee, signer_seeds)?;
    }

    Ok(())
}

/// Execute multi-destination fee distribution for dispute settlement with LOCAL token burn
fn execute_multi_destination_fee_distribution_for_dispute(
    ctx: &Context<SettleDispute>,
    fee_info: &FeeInfo,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let _hub_config = &ctx.accounts.hub_config;
    let _token_mint = &ctx.accounts.token_mint;

    // BURN FEE DISTRIBUTION: Handle LOCAL token burn or conversion + burn
    if fee_info.burn_amount > 0 {
        execute_burn_fee_distribution_for_dispute(ctx, fee_info.burn_amount, signer_seeds)?;
    }

    // CHAIN FEE DISTRIBUTION: Transfer to chain fee collector
    if fee_info.chain_amount > 0 {
        execute_chain_fee_distribution_for_dispute(ctx, fee_info.chain_amount, signer_seeds)?;
    }

    // WARCHEST FEE DISTRIBUTION: Transfer to warchest address
    if fee_info.warchest_amount > 0 {
        execute_warchest_fee_distribution_for_dispute(ctx, fee_info.warchest_amount, signer_seeds)?;
    }

    // CONVERSION FEE HANDLING: Handle conversion fees if applicable
    if fee_info.conversion_fee > 0 {
        execute_conversion_fee_distribution_for_dispute(
            ctx,
            fee_info.conversion_fee,
            signer_seeds,
        )?;
    }

    Ok(())
}

/// Execute burn fee distribution for dispute settlement with automatic LOCAL token conversion
fn execute_burn_fee_distribution_for_dispute(
    ctx: &Context<SettleDispute>,
    burn_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let hub_config = &ctx.accounts.hub_config;
    let token_mint = &ctx.accounts.token_mint;

    if token_mint.key() == hub_config.local_token_mint {
        // Direct burn for LOCAL tokens
        use anchor_spl::token_interface::Burn;

        let cpi_accounts = Burn {
            mint: ctx.accounts.token_mint.to_account_info(),
            from: ctx.accounts.escrow_token_account.to_account_info(),
            authority: ctx.accounts.trade.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        anchor_spl::token_interface::burn(cpi_ctx, burn_amount)?;
    } else {
        // Transfer to burn reserve account for later conversion + burn
        let cpi_accounts = TransferChecked {
            from: ctx.accounts.escrow_token_account.to_account_info(),
            to: ctx.accounts.burn_reserve_account.to_account_info(),
            authority: ctx.accounts.trade.to_account_info(),
            mint: ctx.accounts.token_mint.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        transfer_checked(cpi_ctx, burn_amount, token_mint.decimals)?;
    }

    Ok(())
}

/// Execute chain fee distribution for dispute settlement
fn execute_chain_fee_distribution_for_dispute(
    ctx: &Context<SettleDispute>,
    chain_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.chain_fee_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, chain_amount, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Execute warchest fee distribution for dispute settlement
fn execute_warchest_fee_distribution_for_dispute(
    ctx: &Context<SettleDispute>,
    warchest_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.warchest_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, warchest_amount, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Execute conversion fee distribution for dispute settlement
fn execute_conversion_fee_distribution_for_dispute(
    ctx: &Context<SettleDispute>,
    conversion_fee: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    // For now, route conversion fees to treasury until DEX integration is complete
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.treasury_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, conversion_fee, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Execute burn fee distribution with automatic LOCAL token conversion
fn execute_burn_fee_distribution(
    ctx: &Context<ReleaseEscrow>,
    burn_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let hub_config = &ctx.accounts.hub_config;
    let token_mint = &ctx.accounts.token_mint;

    if token_mint.key() == hub_config.local_token_mint {
        // Direct burn for LOCAL tokens
        execute_direct_local_burn(ctx, burn_amount, signer_seeds)?;
    } else {
        // Convert to LOCAL and burn (requires conversion infrastructure)
        execute_convert_and_burn(ctx, burn_amount, signer_seeds)?;
    }

    Ok(())
}

/// Execute direct LOCAL token burn
fn execute_direct_local_burn(
    ctx: &Context<ReleaseEscrow>,
    burn_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    use anchor_spl::token_interface::Burn;

    // Burn LOCAL tokens directly from escrow
    let cpi_accounts = Burn {
        mint: ctx.accounts.token_mint.to_account_info(),
        from: ctx.accounts.escrow_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    anchor_spl::token_interface::burn(cpi_ctx, burn_amount)?;

    Ok(())
}

/// Execute convert and burn for non-LOCAL tokens
fn execute_convert_and_burn(
    ctx: &Context<ReleaseEscrow>,
    burn_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    // In production, this would:
    // 1. Transfer non-LOCAL tokens to conversion account
    // 2. Execute Jupiter swap to LOCAL
    // 3. Burn the resulting LOCAL tokens

    // For now, transfer to burn reserve account (to be converted later)
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.burn_reserve_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, burn_amount, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Execute chain fee distribution
fn execute_chain_fee_distribution(
    ctx: &Context<ReleaseEscrow>,
    chain_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.chain_fee_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, chain_amount, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Execute warchest fee distribution
fn execute_warchest_fee_distribution(
    ctx: &Context<ReleaseEscrow>,
    warchest_amount: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.warchest_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, warchest_amount, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Execute conversion fee distribution
fn execute_conversion_fee_distribution(
    ctx: &Context<ReleaseEscrow>,
    conversion_fee: u64,
    signer_seeds: &[&[&[u8]]],
) -> Result<()> {
    // Conversion fees go to treasury for DEX operation compensation
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.escrow_token_account.to_account_info(),
        to: ctx.accounts.treasury_token_account.to_account_info(),
        authority: ctx.accounts.trade.to_account_info(),
        mint: ctx.accounts.token_mint.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

    transfer_checked(cpi_ctx, conversion_fee, ctx.accounts.token_mint.decimals)?;

    Ok(())
}

/// Get trades by specific participant (buyer or seller)
pub fn get_trades_by_participant(
    ctx: Context<GetTradesByParticipant>,
    params: GetTradesByParticipantParams,
) -> Result<TradesResponse> {
    validate_pagination_params(&params.pagination)?;

    let program_id = ctx.program_id;
    let participant_filter = TradeFilter {
        participant: Some(params.participant),
        role: params.participant_role,
        ..Default::default()
    };
    let filters = build_trade_filters(&participant_filter)?;

    let accounts = load_program_accounts_filtered(
        ctx.accounts.system_program.to_account_info(),
        program_id,
        &filters,
        &params.pagination,
    )?;

    let trades = deserialize_trade_accounts(accounts)?;

    let next_cursor = get_next_cursor_trade(&trades);
    let has_more = trades.len() >= params.pagination.limit as usize;

    Ok(TradesResponse {
        trades,
        pagination: PaginationResponse {
            next_cursor,
            has_more,
            total_estimate: None,
        },
    })
}

/// Get single trade by ID
pub fn get_trade(ctx: Context<GetTrade>, _trade_id: u64) -> Result<TradeResponse> {
    let trade = &ctx.accounts.trade;

    Ok(TradeResponse {
        trade: (**trade).clone(),
        metadata: TradeMetadata {
            age_seconds: Clock::get()?.unix_timestamp as u64 - trade.created_at,
            is_expired: Clock::get()?.unix_timestamp as u64 > trade.expires_at,
            time_to_expiry: if (Clock::get()?.unix_timestamp as u64) < trade.expires_at {
                Some(trade.expires_at - Clock::get()?.unix_timestamp as u64)
            } else {
                None
            },
            state_duration_seconds: calculate_state_duration(trade)?,
        },
    })
}

/// Get trade history with date range and status filters
pub fn get_trade_history(
    ctx: Context<GetTradeHistory>,
    params: GetTradeHistoryParams,
) -> Result<TradeHistoryResponse> {
    validate_pagination_params(&params.pagination)?;
    validate_date_range_params(&params.date_range)?;

    let program_id = ctx.program_id;
    let history_filter = TradeFilter {
        created_after: params.date_range.start_date,
        created_before: params.date_range.end_date,
        state: params.state_filter,
        ..Default::default()
    };
    let filters = build_trade_filters(&history_filter)?;

    let accounts = load_program_accounts_filtered(
        ctx.accounts.system_program.to_account_info(),
        program_id,
        &filters,
        &params.pagination,
    )?;

    let trades = deserialize_trade_accounts(accounts)?;
    let history_items = convert_trades_to_history(&trades, &params.date_range)?;

    Ok(TradeHistoryResponse {
        history: history_items,
        pagination: PaginationResponse {
            next_cursor: get_next_cursor_trade(&trades),
            has_more: trades.len() >= params.pagination.limit as usize,
            total_estimate: None,
        },
        summary: calculate_history_summary(&trades)?,
    })
}

/// Get trade statistics and analytics
pub fn get_trade_stats(
    ctx: Context<GetTradeStats>,
    params: GetTradeStatsParams,
) -> Result<TradeStatsResponse> {
    let program_id = ctx.program_id;
    let filters = build_trade_filters(&params.filter)?;

    let accounts = load_program_accounts_filtered(
        ctx.accounts.system_program.to_account_info(),
        program_id,
        &filters,
        &PaginationParams {
            limit: 1000, // Reasonable limit for stats calculation
            cursor: None,
            direction: PaginationDirection::Forward,
        },
    )?;

    let trades = deserialize_trade_accounts(accounts)?;
    let stats = calculate_trade_statistics(&trades)?;

    Ok(stats)
}

/// Search trades with complex filtering and analytics
pub fn search_trades(
    ctx: Context<SearchTrades>,
    params: SearchTradesParams,
) -> Result<TradesResponse> {
    validate_pagination_params(&params.pagination)?;
    validate_search_trade_params(&params)?;

    let program_id = ctx.program_id;
    let filters = build_search_trade_filters(&params)?;

    let accounts = load_program_accounts_filtered(
        ctx.accounts.system_program.to_account_info(),
        program_id,
        &filters,
        &params.pagination,
    )?;

    let trades = deserialize_trade_accounts(accounts)?;
    let filtered_trades = apply_advanced_trade_filters(trades, &params)?;

    let next_cursor = get_next_cursor_trade(&filtered_trades);
    let has_more = filtered_trades.len() >= params.pagination.limit as usize;

    Ok(TradesResponse {
        trades: filtered_trades,
        pagination: PaginationResponse {
            next_cursor,
            has_more,
            total_estimate: None,
        },
    })
}

/// Get arbitration cases and dispute analytics
pub fn get_arbitration_cases(
    ctx: Context<GetArbitrationCases>,
    params: GetArbitrationCasesParams,
) -> Result<ArbitrationCasesResponse> {
    validate_pagination_params(&params.pagination)?;

    let program_id = ctx.program_id;
    let arbitration_filter = TradeFilter {
        state: Some(TradeState::DisputeOpened),
        arbitrator: params.arbitrator,
        ..Default::default()
    };
    let filters = build_trade_filters(&arbitration_filter)?;

    let accounts = load_program_accounts_filtered(
        ctx.accounts.system_program.to_account_info(),
        program_id,
        &filters,
        &params.pagination,
    )?;

    let trades = deserialize_trade_accounts(accounts)?;
    let cases = convert_trades_to_arbitration_cases(&trades)?;

    Ok(ArbitrationCasesResponse {
        cases,
        pagination: PaginationResponse {
            next_cursor: get_next_cursor_trade(&trades),
            has_more: trades.len() >= params.pagination.limit as usize,
            total_estimate: None,
        },
        arbitration_stats: calculate_arbitration_statistics(&trades)?,
    })
}

// ==================== QUERY ACCOUNT CONTEXTS ====================

#[derive(Accounts)]
pub struct GetTrades<'info> {
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct GetTradesByParticipant<'info> {
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(trade_id: u64)]
pub struct GetTrade<'info> {
    #[account(
        seeds = [b"trade".as_ref(), trade_id.to_le_bytes().as_ref()],
        bump = trade.bump
    )]
    pub trade: Account<'info, Trade>,
}

#[derive(Accounts)]
pub struct GetTradeHistory<'info> {
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct GetTradeStats<'info> {
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SearchTrades<'info> {
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct GetArbitrationCases<'info> {
    pub system_program: Program<'info, System>,
}

// ==================== QUERY PARAMETERS ====================

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct GetTradesParams {
    pub filter: TradeFilter,
    pub pagination: PaginationParams,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct GetTradesByParticipantParams {
    pub participant: Pubkey,
    pub participant_role: Option<ParticipantRole>,
    pub pagination: PaginationParams,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct GetTradeHistoryParams {
    pub date_range: DateRangeParams,
    pub state_filter: Option<TradeState>,
    pub pagination: PaginationParams,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct GetTradeStatsParams {
    pub filter: TradeFilter,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct SearchTradesParams {
    pub filter: TradeFilter,
    pub pagination: PaginationParams,
    pub sort_by: Option<TradeSortBy>,
    pub amount_range: Option<AmountRange>,
    pub include_expired: Option<bool>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct GetArbitrationCasesParams {
    pub arbitrator: Option<Pubkey>,
    pub case_status: Option<ArbitrationStatus>,
    pub pagination: PaginationParams,
}

// ==================== FILTER AND PARAMETER TYPES ====================

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, Default)]
pub struct TradeFilter {
    pub participant: Option<Pubkey>,
    pub buyer: Option<Pubkey>,
    pub seller: Option<Pubkey>,
    pub arbitrator: Option<Pubkey>,
    pub offer_id: Option<u64>,
    pub state: Option<TradeState>,
    pub fiat_currency: Option<FiatCurrency>,
    pub token_mint: Option<Pubkey>,
    pub min_amount: Option<u64>,
    pub max_amount: Option<u64>,
    pub created_after: Option<u64>,
    pub created_before: Option<u64>,
    pub expires_after: Option<u64>,
    pub expires_before: Option<u64>,
    pub role: Option<ParticipantRole>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct DateRangeParams {
    pub start_date: Option<u64>,
    pub end_date: Option<u64>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum ParticipantRole {
    Buyer,
    Seller,
    Arbitrator,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum TradeSortBy {
    CreatedAt,
    ExpiresAt,
    Amount,
    LockedPrice,
    State,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct AmountRange {
    pub min_amount: Option<u64>,
    pub max_amount: Option<u64>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum ArbitrationStatus {
    Pending,
    InProgress,
    Resolved,
    Expired,
}

// ==================== RESPONSE TYPES ====================

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradesResponse {
    pub trades: Vec<Trade>,
    pub pagination: PaginationResponse,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeResponse {
    pub trade: Trade,
    pub metadata: TradeMetadata,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeMetadata {
    pub age_seconds: u64,
    pub is_expired: bool,
    pub time_to_expiry: Option<u64>,
    pub state_duration_seconds: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeHistoryResponse {
    pub history: Vec<TradeHistoryItem>,
    pub pagination: PaginationResponse,
    pub summary: TradeHistorySummary,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeHistoryItem {
    pub trade_id: u64,
    pub buyer: Pubkey,
    pub seller: Pubkey,
    pub amount: u64,
    pub fiat_currency: FiatCurrency,
    pub state: TradeState,
    pub created_at: u64,
    pub completed_at: Option<u64>,
    pub duration_seconds: Option<u64>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeHistorySummary {
    pub total_trades: u64,
    pub total_volume: u64,
    pub completed_trades: u64,
    pub disputed_trades: u64,
    pub average_completion_time: u64,
    pub success_rate: u64, // Basis points (10000 = 100%)
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeStatsResponse {
    pub total_trades: u64,
    pub trades_by_state: Vec<StateCount>,
    pub trades_by_currency: Vec<CurrencyTradeStats>,
    pub volume_statistics: VolumeStatistics,
    pub time_statistics: TimeStatistics,
    pub arbitration_statistics: ArbitrationStatistics,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct StateCount {
    pub state: TradeState,
    pub count: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct CurrencyTradeStats {
    pub currency: FiatCurrency,
    pub trade_count: u64,
    pub total_volume: u64,
    pub average_amount: u64,
    pub average_locked_price: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct VolumeStatistics {
    pub total_volume: u64,
    pub average_trade_size: u64,
    pub largest_trade: u64,
    pub smallest_trade: u64,
    pub median_trade_size: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TimeStatistics {
    pub average_completion_time: u64,
    pub fastest_completion: u64,
    pub slowest_completion: u64,
    pub average_response_time: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ArbitrationStatistics {
    pub total_disputes: u64,
    pub resolved_disputes: u64,
    pub pending_disputes: u64,
    pub dispute_rate: u64, // Basis points
    pub average_resolution_time: u64,
    pub buyer_wins: u64,
    pub seller_wins: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ArbitrationCasesResponse {
    pub cases: Vec<ArbitrationCase>,
    pub pagination: PaginationResponse,
    pub arbitration_stats: ArbitrationStatistics,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ArbitrationCase {
    pub trade_id: u64,
    pub buyer: Pubkey,
    pub seller: Pubkey,
    pub arbitrator: Pubkey,
    pub amount: u64,
    pub fiat_currency: FiatCurrency,
    pub dispute_opened_at: u64,
    pub dispute_expires_at: Option<u64>,
    pub case_status: ArbitrationStatus,
    pub resolution: Option<DisputeResolution>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct DisputeResolution {
    pub winner: Pubkey,
    pub resolved_at: u64,
    pub resolution_reason: Option<String>,
}

// ==================== HELPER FUNCTIONS ====================

fn validate_date_range_params(params: &DateRangeParams) -> Result<()> {
    if let (Some(start), Some(end)) = (params.start_date, params.end_date) {
        require!(start <= end, ErrorCode::InvalidParameter);
    }
    Ok(())
}

fn validate_search_trade_params(params: &SearchTradesParams) -> Result<()> {
    // Validate amount range
    if let Some(amount_range) = &params.amount_range {
        if let (Some(min), Some(max)) = (amount_range.min_amount, amount_range.max_amount) {
            require!(min <= max, ErrorCode::InvalidParameter);
        }
    }

    // Validate date range in filter
    if let (Some(after), Some(before)) = (params.filter.created_after, params.filter.created_before)
    {
        require!(after <= before, ErrorCode::InvalidParameter);
    }

    // Validate expiry date range
    if let (Some(after), Some(before)) = (params.filter.expires_after, params.filter.expires_before)
    {
        require!(after <= before, ErrorCode::InvalidParameter);
    }

    Ok(())
}

fn build_trade_filters(filter: &TradeFilter) -> Result<Vec<RpcFilterType>> {
    let mut filters = Vec::new();

    // Add discriminator filter for Trade accounts
    filters.push(RpcFilterType::Memcmp(Memcmp::new(
        0, // offset 0 for discriminator
        MemcmpEncodedBytes::Base64(
            "TradeDiscriminator".to_string(), // Placeholder - replace with actual discriminator
        ),
    )));

    // Filter by buyer if specified
    if let Some(buyer) = filter.buyer {
        filters.push(RpcFilterType::Memcmp(Memcmp::new(
            8 + 8 + 8, // offset: discriminator + id + offer_id
            MemcmpEncodedBytes::Base58(buyer.to_string()),
        )));
    }

    // Filter by seller if specified
    if let Some(seller) = filter.seller {
        filters.push(RpcFilterType::Memcmp(Memcmp::new(
            8 + 8 + 8 + 32, // offset: discriminator + id + offer_id + buyer
            MemcmpEncodedBytes::Base58(seller.to_string()),
        )));
    }

    // Filter by state if specified
    if let Some(state) = &filter.state {
        let state_byte = trade_state_to_byte(state);
        filters.push(RpcFilterType::Memcmp(Memcmp::new(
            get_trade_state_offset(), // Calculate actual offset to state field
            MemcmpEncodedBytes::Base58(format!("{}", state_byte)),
        )));
    }

    Ok(filters)
}

fn build_search_trade_filters(params: &SearchTradesParams) -> Result<Vec<RpcFilterType>> {
    build_trade_filters(&params.filter)
}

fn deserialize_trade_accounts(accounts: Vec<(Pubkey, AccountInfo)>) -> Result<Vec<Trade>> {
    let mut trades = Vec::new();

    for (_, account_info) in accounts {
        // Skip discriminator (8 bytes) and deserialize
        let data = &account_info.data.borrow()[8..];
        let trade: Trade = AnchorDeserialize::deserialize(&mut &data[..])?;
        trades.push(trade);
    }

    Ok(trades)
}

fn get_next_cursor_trade(trades: &[Trade]) -> Option<String> {
    if trades.is_empty() {
        return None;
    }

    let last_trade = trades.last().unwrap();
    Some(format!("{}_{}", last_trade.id, last_trade.created_at))
}

fn calculate_state_duration(trade: &Trade) -> Result<u64> {
    let current_time = Clock::get()?.unix_timestamp as u64;
    if let Some(last_state_change) = trade.state_history.last() {
        Ok(current_time.saturating_sub(last_state_change.timestamp as u64))
    } else {
        Ok(current_time.saturating_sub(trade.created_at))
    }
}

fn convert_trades_to_history(
    trades: &[Trade],
    _date_range: &DateRangeParams,
) -> Result<Vec<TradeHistoryItem>> {
    let mut history_items = Vec::new();

    for trade in trades {
        let completed_at = trade
            .state_history
            .iter()
            .find(|item| matches!(item.state, TradeState::Released | TradeState::Refunded))
            .map(|item| item.timestamp);

        let duration_seconds =
            completed_at.map(|completed| completed.saturating_sub(trade.created_at as i64));

        history_items.push(TradeHistoryItem {
            trade_id: trade.id,
            buyer: trade.buyer,
            seller: trade.seller,
            amount: trade.amount,
            fiat_currency: trade.fiat_currency.clone(),
            state: trade.state.clone(),
            created_at: trade.created_at,
            completed_at: completed_at.map(|t| t as u64),
            duration_seconds: duration_seconds.map(|t| t as u64),
        });
    }

    Ok(history_items)
}

fn calculate_history_summary(trades: &[Trade]) -> Result<TradeHistorySummary> {
    let total_trades = trades.len() as u64;
    let mut total_volume = 0u64;
    let mut completed_trades = 0u64;
    let mut disputed_trades = 0u64;
    let mut total_completion_time = 0u64;

    for trade in trades {
        total_volume += trade.amount;

        if matches!(trade.state, TradeState::Released | TradeState::Refunded) {
            completed_trades += 1;

            if let Some(completion_time) = trade
                .state_history
                .iter()
                .find(|item| matches!(item.state, TradeState::Released | TradeState::Refunded))
                .map(|item| (item.timestamp - trade.created_at as i64).max(0) as u64)
            {
                total_completion_time += completion_time;
            }
        }

        if matches!(
            trade.state,
            TradeState::DisputeOpened | TradeState::DisputeResolved
        ) {
            disputed_trades += 1;
        }
    }

    let average_completion_time = if completed_trades > 0 {
        total_completion_time / completed_trades
    } else {
        0
    };

    let success_rate = if total_trades > 0 {
        (completed_trades * 10000) / total_trades // Basis points
    } else {
        0
    };

    Ok(TradeHistorySummary {
        total_trades,
        total_volume,
        completed_trades,
        disputed_trades,
        average_completion_time,
        success_rate,
    })
}

fn calculate_trade_statistics(trades: &[Trade]) -> Result<TradeStatsResponse> {
    let total_trades = trades.len() as u64;
    let mut state_counts = HashMap::new();
    let mut currency_stats = HashMap::new();
    let mut amounts = Vec::new();
    let mut completion_times = Vec::new();
    let mut dispute_count = 0u64;
    let mut resolved_disputes = 0u64;

    for trade in trades {
        // Count by state
        let state_key = trade_state_to_byte(&trade.state);
        *state_counts.entry(state_key).or_insert(0u64) += 1;

        // Collect amounts
        amounts.push(trade.amount);

        // Track currency stats
        let currency_stat =
            currency_stats
                .entry(trade.fiat_currency.clone())
                .or_insert(CurrencyTradeStats {
                    currency: trade.fiat_currency.clone(),
                    trade_count: 0,
                    total_volume: 0,
                    average_amount: 0,
                    average_locked_price: 0,
                });
        currency_stat.trade_count += 1;
        currency_stat.total_volume += trade.amount;

        // Track dispute statistics
        if matches!(
            trade.state,
            TradeState::DisputeOpened | TradeState::DisputeResolved
        ) {
            dispute_count += 1;
            if matches!(trade.state, TradeState::DisputeResolved) {
                resolved_disputes += 1;
            }
        }

        // Track completion times
        if let Some(completion_time) = trade
            .state_history
            .iter()
            .find(|item| matches!(item.state, TradeState::Released | TradeState::Refunded))
            .map(|item| (item.timestamp - trade.created_at as i64).max(0) as u64)
        {
            completion_times.push(completion_time);
        }
    }

    // Calculate volume statistics
    amounts.sort_unstable();
    let total_volume: u64 = amounts.iter().sum();
    let volume_statistics = VolumeStatistics {
        total_volume,
        average_trade_size: if total_trades > 0 {
            total_volume / total_trades
        } else {
            0
        },
        largest_trade: amounts.last().copied().unwrap_or(0),
        smallest_trade: amounts.first().copied().unwrap_or(0),
        median_trade_size: if amounts.is_empty() {
            0
        } else {
            amounts[amounts.len() / 2]
        },
    };

    // Calculate time statistics
    completion_times.sort_unstable();
    let time_statistics = TimeStatistics {
        average_completion_time: if completion_times.is_empty() {
            0
        } else {
            completion_times.iter().sum::<u64>() / completion_times.len() as u64
        },
        fastest_completion: completion_times.first().copied().unwrap_or(0),
        slowest_completion: completion_times.last().copied().unwrap_or(0),
        average_response_time: 0, // Placeholder - would need more detailed tracking
    };

    // Build response
    let trades_by_state = state_counts
        .into_iter()
        .map(|(state_byte, count)| StateCount {
            state: byte_to_trade_state(state_byte),
            count,
        })
        .collect();
    let trades_by_currency = currency_stats.into_values().collect();

    let arbitration_statistics = ArbitrationStatistics {
        total_disputes: dispute_count,
        resolved_disputes,
        pending_disputes: dispute_count.saturating_sub(resolved_disputes),
        dispute_rate: if total_trades > 0 {
            (dispute_count * 10000) / total_trades
        } else {
            0
        },
        average_resolution_time: 0, // Placeholder
        buyer_wins: 0,              // Placeholder
        seller_wins: 0,             // Placeholder
    };

    Ok(TradeStatsResponse {
        total_trades,
        trades_by_state,
        trades_by_currency,
        volume_statistics,
        time_statistics,
        arbitration_statistics,
    })
}

fn apply_advanced_trade_filters(
    trades: Vec<Trade>,
    params: &SearchTradesParams,
) -> Result<Vec<Trade>> {
    let mut filtered = trades;

    // Apply amount range filter
    if let Some(amount_range) = &params.amount_range {
        if let Some(min_amount) = amount_range.min_amount {
            filtered.retain(|trade| trade.amount >= min_amount);
        }
        if let Some(max_amount) = amount_range.max_amount {
            filtered.retain(|trade| trade.amount <= max_amount);
        }
    }

    // Apply expiry filter
    if let Some(include_expired) = params.include_expired {
        let current_time = Clock::get().unwrap().unix_timestamp as u64;
        if !include_expired {
            filtered.retain(|trade| trade.expires_at > current_time);
        }
    }

    // Apply sorting
    if let Some(sort_by) = &params.sort_by {
        match sort_by {
            TradeSortBy::CreatedAt => {
                filtered.sort_by(|a, b| b.created_at.cmp(&a.created_at));
            }
            TradeSortBy::ExpiresAt => {
                filtered.sort_by(|a, b| a.expires_at.cmp(&b.expires_at));
            }
            TradeSortBy::Amount => {
                filtered.sort_by(|a, b| b.amount.cmp(&a.amount));
            }
            TradeSortBy::LockedPrice => {
                filtered.sort_by(|a, b| a.locked_price.cmp(&b.locked_price));
            }
            TradeSortBy::State => {
                filtered.sort_by(|a, b| {
                    trade_state_to_byte(&a.state).cmp(&trade_state_to_byte(&b.state))
                });
            }
        }
    }

    Ok(filtered)
}

fn convert_trades_to_arbitration_cases(trades: &[Trade]) -> Result<Vec<ArbitrationCase>> {
    let mut cases = Vec::new();

    for trade in trades {
        if matches!(
            trade.state,
            TradeState::DisputeOpened | TradeState::DisputeResolved
        ) {
            let case_status = match trade.state {
                TradeState::DisputeOpened => ArbitrationStatus::Pending,
                TradeState::DisputeResolved => ArbitrationStatus::Resolved,
                _ => ArbitrationStatus::Pending,
            };

            let dispute_opened_at = trade
                .state_history
                .iter()
                .find(|item| matches!(item.state, TradeState::DisputeOpened))
                .map(|item| item.timestamp)
                .unwrap_or(trade.created_at as i64);

            cases.push(ArbitrationCase {
                trade_id: trade.id,
                buyer: trade.buyer,
                seller: trade.seller,
                arbitrator: trade.arbitrator,
                amount: trade.amount,
                fiat_currency: trade.fiat_currency.clone(),
                dispute_opened_at: dispute_opened_at as u64,
                dispute_expires_at: trade.dispute_window_at,
                case_status,
                resolution: None, // Would need additional data structure to track resolutions
            });
        }
    }

    Ok(cases)
}

fn calculate_arbitration_statistics(trades: &[Trade]) -> Result<ArbitrationStatistics> {
    let mut total_disputes = 0u64;
    let mut resolved_disputes = 0u64;
    let mut pending_disputes = 0u64;

    for trade in trades {
        match trade.state {
            TradeState::DisputeOpened => {
                total_disputes += 1;
                pending_disputes += 1;
            }
            TradeState::DisputeResolved => {
                total_disputes += 1;
                resolved_disputes += 1;
            }
            _ => {}
        }
    }

    let dispute_rate = if trades.len() > 0 {
        (total_disputes * 10000) / trades.len() as u64
    } else {
        0
    };

    Ok(ArbitrationStatistics {
        total_disputes,
        resolved_disputes,
        pending_disputes,
        dispute_rate,
        average_resolution_time: 0, // Placeholder
        buyer_wins: 0,              // Placeholder
        seller_wins: 0,             // Placeholder
    })
}

// Helper functions for trade state management
fn trade_state_to_byte(state: &TradeState) -> u8 {
    match state {
        TradeState::RequestCreated => 0,
        TradeState::RequestAccepted => 1,
        TradeState::EscrowFunded => 2,
        TradeState::FiatDeposited => 3,
        TradeState::Released => 4,
        TradeState::DisputeOpened => 5,
        TradeState::DisputeResolved => 6,
        TradeState::Refunded => 7,
        TradeState::RequestCanceled => 8,
        TradeState::RequestExpired => 9,
        TradeState::EscrowCanceled => 10,
        TradeState::EscrowRefunded => 11,
        TradeState::EscrowReleased => 12,
        TradeState::EscrowDisputed => 13,
        TradeState::SettledForMaker => 14,
        TradeState::SettledForTaker => 15,
    }
}

fn get_trade_state_offset() -> usize {
    // This would need to be calculated based on the actual Trade struct layout
    // Placeholder value
    200
}

fn byte_to_trade_state(byte: u8) -> TradeState {
    match byte {
        0 => TradeState::RequestCreated,
        1 => TradeState::RequestAccepted,
        2 => TradeState::EscrowFunded,
        3 => TradeState::FiatDeposited,
        4 => TradeState::Released,
        5 => TradeState::DisputeOpened,
        6 => TradeState::DisputeResolved,
        7 => TradeState::Refunded,
        8 => TradeState::RequestCanceled,
        9 => TradeState::RequestExpired,
        10 => TradeState::EscrowCanceled,
        11 => TradeState::EscrowRefunded,
        12 => TradeState::EscrowReleased,
        13 => TradeState::EscrowDisputed,
        14 => TradeState::SettledForMaker,
        15 => TradeState::SettledForTaker,
        _ => TradeState::RequestCreated, // Default fallback
    }
}

// Common pagination and filtering types (shared with offer program)
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PaginationParams {
    pub limit: u32,
    pub cursor: Option<String>,
    pub direction: PaginationDirection,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum PaginationDirection {
    Forward,
    Backward,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PaginationResponse {
    pub next_cursor: Option<String>,
    pub has_more: bool,
    pub total_estimate: Option<u64>,
}

#[derive(Clone, Debug)]
pub enum RpcFilterType {
    Memcmp(Memcmp),
    DataSize(u64),
}

#[derive(Clone, Debug)]
pub struct Memcmp {
    pub offset: usize,
    pub bytes: MemcmpEncodedBytes,
}

impl Memcmp {
    pub fn new(offset: usize, bytes: MemcmpEncodedBytes) -> Self {
        Self { offset, bytes }
    }
}

#[derive(Clone, Debug)]
pub enum MemcmpEncodedBytes {
    Base58(String),
    Base64(String),
}

fn validate_pagination_params(params: &PaginationParams) -> Result<()> {
    const MAX_LIMIT: u32 = 100;
    const MIN_LIMIT: u32 = 1;

    require!(
        params.limit >= MIN_LIMIT && params.limit <= MAX_LIMIT,
        ErrorCode::InvalidParameter
    );

    Ok(())
}

fn load_program_accounts_filtered<'a>(
    _system_program: AccountInfo<'a>,
    _program_id: &Pubkey,
    _filters: &[RpcFilterType],
    _pagination: &PaginationParams,
) -> Result<Vec<(Pubkey, AccountInfo<'a>)>> {
    // Placeholder implementation
    Ok(Vec::new())
}

// ==================== COMMIT-REVEAL CONTEXT STRUCTS ====================

#[derive(Accounts)]
#[instruction(trade_id: u64)]
pub struct CommitRandomness<'info> {
    #[account(mut)]
    pub trade: Account<'info, Trade>,
    
    #[account(
        init_if_needed,
        payer = committer,
        space = 8 + CommitRevealRandomness::INIT_SPACE,
        seeds = [b"commit_reveal", trade_id.to_le_bytes().as_ref()],
        bump
    )]
    pub commit_reveal: Account<'info, CommitRevealRandomness>,
    
    #[account(mut)]
    pub committer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RevealRandomness<'info> {
    #[account(mut)]
    pub trade: Account<'info, Trade>,
    
    #[account(
        mut,
        seeds = [b"commit_reveal", trade.id.to_le_bytes().as_ref()],
        bump = commit_reveal.bump
    )]
    pub commit_reveal: Account<'info, CommitRevealRandomness>,
    
    pub arbitrator_pool: Account<'info, ArbitratorPool>,
    
    pub revealer: Signer<'info>,
}

#[derive(Accounts)]
#[instruction(trade_id: u64)]
pub struct SelectWeightedArbitrator<'info> {
    #[account(mut)]
    pub trade: Account<'info, Trade>,
    
    pub arbitrator_pool: Account<'info, ArbitratorPool>,
    
    /// CHECK: Recent blockhashes sysvar for additional entropy
    pub recent_blockhashes: AccountInfo<'info>,
    
    pub authority: Signer<'info>,
}

// ==================== RANDOMNESS EVENTS ====================

#[event]
pub struct RandomnessCommittedEvent {
    pub trade_id: u64,
    pub committer: Pubkey,
    pub commitment: String,
    pub timestamp: i64,
}

#[event]
pub struct ArbitratorSelectedEvent {
    pub trade_id: u64,
    pub arbitrator: Pubkey,
    pub randomness: String,
    pub timestamp: i64,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access")]
    Unauthorized,
    #[msg("Invalid trade state")]
    InvalidTradeState,
    #[msg("Arithmetic error")]
    ArithmeticError,
    #[msg("Arithmetic overflow")]
    ArithmeticOverflow,
    #[msg("Arithmetic underflow")]
    ArithmeticUnderflow,
    #[msg("Division by zero")]
    DivisionByZero,
    #[msg("Trade expired")]
    TradeExpired,
    #[msg("Dispute window not open")]
    DisputeWindowNotOpen,
    #[msg("Arbitrator already exists")]
    ArbitratorAlreadyExists,
    #[msg("Arbitrator pool is full")]
    ArbitratorPoolFull,
    #[msg("No arbitrators available")]
    NoArbitratorsAvailable,
    #[msg("Invalid arbitrator")]
    InvalidArbitrator,
    #[msg("Premature dispute request")]
    PrematureDisputeRequest,
    #[msg("Invalid winner")]
    InvalidWinner,
    #[msg("Trade amount below minimum")]
    TradeBelowMinimum,
    #[msg("Trade amount above maximum")]
    TradeAboveMaximum,
    #[msg("Invalid trade amount")]
    InvalidTradeAmount,
    #[msg("Invalid locked price")]
    InvalidLockedPrice,
    #[msg("Invalid state transition")]
    InvalidStateTransition,
    #[msg("Invalid account")]
    InvalidAccount,
    #[msg("Self trade not allowed")]
    SelfTradeNotAllowed,
    #[msg("Invalid arbitrator assignment")]
    InvalidArbitratorAssignment,
    #[msg("Unauthorized CPI call")]
    UnauthorizedCpiCall,
    #[msg("Invalid CPI data")]
    InvalidCpiData,
    #[msg("Excessive fees")]
    ExcessiveFees,
    #[msg("Excessive burn fee")]
    ExcessiveBurnFee,
    #[msg("Excessive chain fee")]
    ExcessiveChainFee,
    #[msg("Excessive warchest fee")]
    ExcessiveWarchestFee,
    #[msg("Refund not allowed")]
    RefundNotAllowed,
    #[msg("Refund too early")]
    RefundTooEarly,
    #[msg("Invalid parameter")]
    InvalidParameter,

    // ADVANCED FEE MANAGEMENT: New error codes for enhanced fee system
    #[msg("Excessive conversion fee")]
    ExcessiveConversionFee,
    #[msg("Excessive arbitration fees")]
    ExcessiveArbitrationFees,
    #[msg("Excessive arbitrator fee")]
    ExcessiveArbitratorFee,
    #[msg("Token conversion failed")]
    TokenConversionFailed,
    #[msg("Slippage exceeded maximum")]
    SlippageExceeded,
    #[msg("Insufficient conversion amount")]
    InsufficientConversionAmount,
    #[msg("Invalid conversion route")]
    InvalidConversionRoute,
    #[msg("DEX operation failed")]
    DexOperationFailed,
    #[msg("Token burn failed")]
    TokenBurnFailed,
    #[msg("Invalid fee calculation method")]
    InvalidFeeCalculationMethod,
    #[msg("Conversion route too complex")]
    ConversionRouteTooComplex,
    #[msg("LOCAL token conversion required")]
    LocalTokenConversionRequired,
    #[msg("Invalid DEX program")]
    InvalidDexProgram,
    #[msg("Pool not found")]
    PoolNotFound,
    #[msg("Invalid treasury address")]
    InvalidTreasuryAddress,
    #[msg("Invalid chain fee collector")]
    InvalidChainFeeCollector,
    #[msg("Invalid warchest address")]
    InvalidWarchestAddress,

    // Account validation errors
    #[msg("Invalid token account - does not match expected ATA")]
    InvalidTokenAccount,
    #[msg("Invalid account owner")]
    InvalidAccountOwner,
    #[msg("Invalid PDA - does not match expected derivation")]
    InvalidPDA,
    #[msg("Invalid program account")]
    InvalidProgramAccount,
    #[msg("String exceeds maximum length")]
    StringTooLong,
    #[msg("Collection is full")]
    CollectionFull,
    #[msg("Rate limit exceeded")]
    RateLimitExceeded,
    #[msg("Page is full")]
    PageFull,
    #[msg("Invalid page number")]
    InvalidPageNumber,
    
    // VRF-related error codes
    #[msg("No randomness available from VRF")]
    NoRandomnessAvailable,
    #[msg("No eligible arbitrators available")]
    NoEligibleArbitrators,
    #[msg("VRF request failed")]
    VrfRequestFailed,
    #[msg("Invalid reveal in commit-reveal scheme")]
    InvalidReveal,
    #[msg("Not in reveal phase")]
    NotInRevealPhase,
    #[msg("Commitment not found")]
    NoCommitmentFound,
    #[msg("Already committed randomness")]
    AlreadyCommitted,
    #[msg("Commit phase has ended")]
    CommitPhaseEnded,
    
    // Security-specific error codes
    #[msg("Invalid CPI program")]
    InvalidCpiProgram,
    #[msg("Protected account cannot be modified")]
    ProtectedAccount,
    #[msg("Insufficient rent exemption with safety margin")]
    InsufficientRentExemption,
    #[msg("Reentrancy detected")]
    ReentrancyDetected,
}
